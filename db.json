{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/vexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/catalog.png","path":"css/images/catalog.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/escheres.png","path":"css/images/escheres.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/plugins/gitment.css","path":"css/plugins/gitment.css","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/menu.png","path":"css/images/menu.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/top.png","path":"css/images/top.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","path":"fonts/SourceSansPro.ttf","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/logo.png","path":"css/images/logo.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/vexo/.gitignore","hash":"99e5bb4cc2a0b34f697ecc7c146f9d10d0a986e8","modified":1514287311907},{"_id":"themes/vexo/.travis.yml","hash":"b3ac9cda9d6000736519c78272ea03733f70bbfc","modified":1514287311843},{"_id":"themes/vexo/LICENSE","hash":"96a961acb8766182dca9e15280b37ee18156cee9","modified":1514287311844},{"_id":"themes/vexo/_config.yml","hash":"eabee5218d55ada84e395f240fc81cd859448cd4","modified":1514287311846},{"_id":"themes/vexo/README.md","hash":"0519d952de0640daec890fd723410b735e8ec03d","modified":1514287311845},{"_id":"themes/vexo/lint.sh","hash":"2f3d1e5bab055677cab305b34220ba090a59f49e","modified":1514287311875},{"_id":"themes/vexo/package.json","hash":"ce95b274241ba053218ee00952e0e2f720f4e30b","modified":1514287311876},{"_id":"source/_posts/2014-03-03-learn-ecma262-3rd-edition.md","hash":"47d781d4f8ac083491bf270440db4cd001713976","modified":1514287311776},{"_id":"source/_posts/2014-03-13-the-javascript-event-loop-explained.md","hash":"fd3ef0dc7601ddf57d4f428108746006bc66f1c3","modified":1514287311788},{"_id":"source/_posts/2014-06-23-technical-overview-of-couchdb.md","hash":"a9adc8225ef62d8bee98c61d6dba2064c71c67de","modified":1514287311793},{"_id":"source/about/index.md","hash":"54861b4ba18c5d09a6b0d92429cabd617023caa0","modified":1514287311795},{"_id":"source/project/index.md","hash":"9e533e682312e2dc14844baa0c2576f4ee11169a","modified":1514287311797},{"_id":"themes/vexo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1514287311833},{"_id":"themes/vexo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1514287311834},{"_id":"themes/vexo/.git/config","hash":"60d98f4fa9d7333eaad040f9b417f5263927661b","modified":1514287311841},{"_id":"themes/vexo/.git/index","hash":"37c201f1b70890384a7281de27fd8679a268dd0d","modified":1514287311835},{"_id":"source/tags/index.md","hash":"ae19acf22f855d3acfd9f58d28aebd1bd8ba4def","modified":1514287311799},{"_id":"themes/vexo/.git/packed-refs","hash":"7137f52cccd15a66fd18d96e7c953831d8549d23","modified":1514287311825},{"_id":"themes/vexo/layout/about.ejs","hash":"3222eac822f8cd32c521fa242f16d1ff35e2885c","modified":1514287311866},{"_id":"themes/vexo/layout/archive.ejs","hash":"96ee9d5765fba055a31095cfa2e4532b01ff4656","modified":1514287311867},{"_id":"themes/vexo/layout/index.ejs","hash":"368741bd99b47547cd2aa9ae0b86dce433963b51","modified":1514287311868},{"_id":"themes/vexo/layout/layout.ejs","hash":"f2663b2d38d506488954de4ee88437f7ecd8bef6","modified":1514287311869},{"_id":"themes/vexo/layout/page.ejs","hash":"d0f729abbda1ce6215fb4259bb5ff9c47d5dbd76","modified":1514287311871},{"_id":"themes/vexo/layout/project.ejs","hash":"4224332d7f9791353838024796daf21e993da66e","modified":1514287311872},{"_id":"themes/vexo/layout/tags.ejs","hash":"d212c99fe1283e2939a31c1137a861b985d20054","modified":1514287311874},{"_id":"themes/vexo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1514287311818},{"_id":"themes/vexo/.git/logs/HEAD","hash":"2ce2a47b729b59359ecec8a54113f0a2d6be88f1","modified":1514287311831},{"_id":"themes/vexo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1514287311803},{"_id":"themes/vexo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1514287311805},{"_id":"themes/vexo/.git/hooks/fsmonitor-watchman.sample","hash":"a04bcd7925e722826245dd3085ddbc739ccf12ac","modified":1514287311806},{"_id":"themes/vexo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1514287311807},{"_id":"themes/vexo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1514287311808},{"_id":"themes/vexo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1514287311810},{"_id":"themes/vexo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1514287311811},{"_id":"themes/vexo/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1514287311812},{"_id":"themes/vexo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1514287311816},{"_id":"themes/vexo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1514287311813},{"_id":"themes/vexo/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1514287311815},{"_id":"themes/vexo/_source/about/index.md","hash":"54861b4ba18c5d09a6b0d92429cabd617023caa0","modified":1514287311849},{"_id":"themes/vexo/_source/tags/index.md","hash":"ae19acf22f855d3acfd9f58d28aebd1bd8ba4def","modified":1514287311852},{"_id":"themes/vexo/layout/_partial/catalog.ejs","hash":"388691959db5272d70995c9536c26135e07ec33d","modified":1514287311856},{"_id":"themes/vexo/layout/_partial/footer.ejs","hash":"61ffed08425ad62836a7204061649f8811a533fa","modified":1514287311858},{"_id":"themes/vexo/layout/_partial/pager.ejs","hash":"b56ebe2bff1223b76865c4a43f2a0c28c08e9e7e","modified":1514287311862},{"_id":"themes/vexo/layout/_partial/archive.ejs","hash":"99cf513b3ffdd800672cf7171cd60279fedd8576","modified":1514287311855},{"_id":"themes/vexo/layout/_partial/top.ejs","hash":"cb8abc06fa14d3ccc085629bbff0333d2f7aef37","modified":1514287311864},{"_id":"themes/vexo/layout/_partial/head.ejs","hash":"16a7fc5512d06af005dd62e4f1321c779a94da61","modified":1514287311859},{"_id":"themes/vexo/layout/_partial/header.ejs","hash":"aff5d8e1c7dc9d7ade858291948aca73c549710f","modified":1514287311860},{"_id":"themes/vexo/layout/_partial/tag.ejs","hash":"ff8f66ad350a0da1b7ef03840f70b637024e028c","modified":1514287311863},{"_id":"themes/vexo/_source/project/index.md","hash":"9e533e682312e2dc14844baa0c2576f4ee11169a","modified":1514287311851},{"_id":"themes/vexo/source/css/_config.styl","hash":"b22710203165c07b33a50c60c53515b42e64b8c1","modified":1514287311879},{"_id":"themes/vexo/source/css/style.styl","hash":"d39eddac44fb14243fcef163511fea4dcf5fe146","modified":1514287311902},{"_id":"themes/vexo/source/js/script.js","hash":"40e74312277fbfd1c4891782fc34d4ba660a0c30","modified":1514287311906},{"_id":"themes/vexo/.git/objects/pack/pack-2ec1c2a24eb6b4b89cfd7a1a2585570bc68c2ef8.idx","hash":"23d4c3983f860d7caddd420924c9326a52e33857","modified":1514287311838},{"_id":"themes/vexo/.git/refs/heads/master","hash":"48d846cfc4b177d298d6dc3045428c1cc5e30b36","modified":1514287311820},{"_id":"themes/vexo/source/css/_partial/about.styl","hash":"5295b1e6b342eb6cccecf20e0469df808b7b76e7","modified":1514287311881},{"_id":"themes/vexo/source/css/_partial/archive.styl","hash":"5150e6ed6c9b0613da014304048650659412fd33","modified":1514287311882},{"_id":"themes/vexo/source/css/_partial/footer.styl","hash":"0fa2974f14dc8373e3705bc96d415dae236f49f3","modified":1514287311885},{"_id":"themes/vexo/source/css/_partial/catalog.styl","hash":"c027409e2964f85906813da7ef1dac03ac103960","modified":1514287311883},{"_id":"themes/vexo/source/css/_partial/header.styl","hash":"ba15f5456b578c6c731f1b387cbf7570d5792988","modified":1514287311886},{"_id":"themes/vexo/source/css/_partial/markdown.styl","hash":"928a0ae6870cbd7cbfb6d94a950baf8c632a0efe","modified":1514287311887},{"_id":"themes/vexo/source/css/_partial/pager.styl","hash":"506c59380c56f03b9ddd08fd18cfaaf17888858a","modified":1514287311889},{"_id":"themes/vexo/source/css/_partial/tags.styl","hash":"14cd7fbc4309ed2c470746497af14d79e62b6641","modified":1514287311891},{"_id":"themes/vexo/source/css/_partial/project.styl","hash":"a4dc0b4bdf1b5e8fcd3a4c6f4d9b2ed8c06e72ba","modified":1514287311890},{"_id":"themes/vexo/source/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1514287311893},{"_id":"themes/vexo/source/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1514287311895},{"_id":"themes/vexo/source/css/plugins/gitment.css","hash":"1190f8b5c9962b96c3d3631b15ab8680faa9ddef","modified":1514287311900},{"_id":"themes/vexo/source/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1514287311896},{"_id":"themes/vexo/source/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1514287311897},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1514287311904},{"_id":"themes/vexo/.git/logs/refs/heads/master","hash":"2ce2a47b729b59359ecec8a54113f0a2d6be88f1","modified":1514287311830},{"_id":"themes/vexo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1514287311823},{"_id":"themes/vexo/source/css/images/logo.png","hash":"803f235d10ef5efa09e5dbc91ba543b8e6d7d2c1","modified":1514287311898},{"_id":"themes/vexo/.git/logs/refs/remotes/origin/HEAD","hash":"2ce2a47b729b59359ecec8a54113f0a2d6be88f1","modified":1514287311828},{"_id":"themes/vexo/.git/objects/pack/pack-2ec1c2a24eb6b4b89cfd7a1a2585570bc68c2ef8.pack","hash":"b28a1438c8f6a4b2b17921ed7d7451efb69fb57d","modified":1514287311839},{"_id":"public/about/index.html","hash":"714d95134d21995f324dd92fdcc6fc058dd1cbee","modified":1514287467035},{"_id":"public/project/index.html","hash":"b3c17eb6f5054433f0c5521a4e58cc5515ebbd08","modified":1514287467036},{"_id":"public/tags/index.html","hash":"7db9b29f5816413f3d97ce28fff540fbf1c83cc0","modified":1514287467036},{"_id":"public/categories/javascript/index.html","hash":"5d14fca99901d2241de0f2512ea6d54aaa24d880","modified":1514287467036},{"_id":"public/categories/couchdb/index.html","hash":"324e306268c4a783dfb9a10b7943cdbe07dd8e97","modified":1514287467036},{"_id":"public/index.html","hash":"55b8716570633ba6c0abc5a9891cef923682da68","modified":1514287467036},{"_id":"public/archives/index.html","hash":"919f8eacc2520069ffd923e2071f38800a796e03","modified":1514287467036},{"_id":"public/archives/2014/index.html","hash":"c1562896cff7392fc1a8867fe6a515323eb696d0","modified":1514287467036},{"_id":"public/archives/2014/03/index.html","hash":"c9a5d49c641991409420b7ae4d87dfd139de9146","modified":1514287467036},{"_id":"public/archives/2014/06/index.html","hash":"6e0ba8c154837c11d8c0edd0f6433ae173900f81","modified":1514287467036},{"_id":"public/technical-overview-of-couchdb/index.html","hash":"f5e5654f8f6c3b8cb9218a1752b139ca1784c048","modified":1514287467036},{"_id":"public/the-javascript-event-loop-explained/index.html","hash":"bbe129c74fd3b65c66ffd826d412b592909f77fb","modified":1514287467036},{"_id":"public/learn-ecma262-3rd-edition/index.html","hash":"b1c4cf1fe98ef10d760837d32bafbb7f4368e73b","modified":1514287467036},{"_id":"public/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1514287467039},{"_id":"public/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1514287467039},{"_id":"public/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1514287467039},{"_id":"public/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1514287467039},{"_id":"public/js/script.js","hash":"d742d407a66b2fe9cbbd457d23ed14607b478d3e","modified":1514287467365},{"_id":"public/css/style.css","hash":"16be1b5028906833ba3f7f909172f1acdeb8db0c","modified":1514287467365},{"_id":"public/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1514287467365},{"_id":"public/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1514287467365},{"_id":"public/css/images/logo.png","hash":"803f235d10ef5efa09e5dbc91ba543b8e6d7d2c1","modified":1514287467366}],"Category":[{"name":"javascript","_id":"cjbnjnr9o0004v4tntu17ropu"},{"name":"couchdb","_id":"cjbnjnr9z0008v4tn691dt616"}],"Data":[],"Page":[{"title":"About","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: About\nlayout: about\n---","date":"2017-12-26T11:21:51.795Z","updated":"2017-12-26T11:21:51.795Z","path":"about/index.html","comments":1,"_id":"cjbnjnr9h0001v4tndiuvz1oy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Project","layout":"project","_content":"","source":"project/index.md","raw":"---\ntitle: Project\nlayout: project\n---\n","date":"2017-12-26T11:21:51.797Z","updated":"2017-12-26T11:21:51.797Z","path":"project/index.html","comments":1,"_id":"cjbnjnr9n0003v4tnns9uln4v","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\n---\n","date":"2017-12-26T11:21:51.799Z","updated":"2017-12-26T11:21:51.799Z","path":"tags/index.html","comments":1,"_id":"cjbnjnr9t0006v4tnvlndnvp0","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"读一读 ECMA262 3rd edition","date":"2014-03-03T04:34:56.000Z","_content":"\n## Overview\n\n### Web Scripting\nJavaScript是一种在宿主环境中执行计算和操作计算对象的面向对象编程语言。它起初被设计为一种Web scripting language，用来增加网页的交互性，以及执行一些服务端的计算。ECMAScript规范描述了其在宿主环境中的core scripting能力。\nWeb浏览器为javascript提供了作为客户端计算的宿主环境。它提供了一些对象用来表示windows, menus, pop-ups, dialog boxes, text areas, anchors, frames, history, cookies, 以及input/output。并且，这个宿主环境也提供了一种手段用来将scripting code绑定到一些事件上。例如，change of focus, page and image loading, unloading, error and abort, selection, form submission, 以及mouse actions。Scripting code嵌入在HTML代码当中，显示出来的页面由一些用户界面元素和一些固定位置并已计算好的文本和图像构成。Scripting code在用户的交互下会被触发执行，而不需要一个main程序去触发。\n而Web服务器为javascript提供了另一中作为服务端计算的宿主环境(如node.js)。它提供了一些对象用来表示requests, clients, 以及files。它也提供一种机制来锁住或共享数据。<!--more-->\n\n### Language Overview\nJavascript是基于对象的：语言基础和宿主环境的功能都以对象的方式提供，并且一个javascript程序就是一个由一些相互通信的对象组成的集合。一个javascript对象是一个由properties构成的无序集合。每一个prpperty包含0个或多个attributes，用来决定每个property怎样使用。例如，当一个property的ReadOnly attribute被设置为true的话，任何改变该property的值的操作都会失效。Property是一个容器，用来包含其它的对象：primitive values或者methods。一个原始值(primitive value)是以下内建类型的一个成员：Undefined, Null, Boolean, Number, String。而一个对象则是剩下的Object这一内建类型的一个成员。一个method是一个可以通过property关联到一个对象的function。\njavascript定义了一系列的内建对象，包括Global对象，Object对象，Function对象，Array对象，String对象，Boolean对象，Number对象，Math对象，Date对象，RegExp对象，和一些表示错误的对象(Error对象，EvalError对象，RangeError对象，ReferenceError对象，SyntaxError对象，TypeError对象，URIError对象)。\n\n### Objects\nJavascript并没有其它面向对象语言如C++，Smalltalk，Java等中的class机制来创建新的对象。但javascript有constructor这一构造对象，通过执行constructor的代码来为分配对象空间，并初始化对象空间的一些属性(properties)，从来产生新的对象。所有的constructor都是对象，但并不是所有的对象都是constructor。每一个constructor都有一个名为Prototype的属性(property)，用来实现基于原型的继承(prototype-based inheritance)和共享属性(shared properties)。对象通过在new表达式中使用constructor来创建。例如：new String(\"A String\")将创建一个新的String类型的对象。不使用new来调用constructor产生的效果将因constructor而异。例如：String(\"A String\")将产生一个String类型的原始值(primitive value)，而不会是String类型的对象。\n\nJavascript支持基于prototype的继承。每一个constructor都通过prototype属性来显式关联一个prototype对象。通过constructor对象构造新对象时，将以这个prototype对象为原型进行创建。新产生的对象对这个prototype对象会有一个隐式关联(通过\\_\\_proto\\_\\_属性关联)，通常这个隐式关联在程序中不可直接访问。\n\n这里一共涉及到三个对象。设有一个构造对象Constructor，那么：\n\n* 这个constructor显式关联一个prototype对象：Constructor.prototype(显式原型引用)；\n* 新产生的对象与原型对象有一个隐式引用：NewObject.\\_\\_proto\\_\\_(隐式原型引用)；\n\n```\n+--------------------+  [prototype] +------------------+\n| Constructor Object |+------------>| Prototype Object |\n+--------------------+      ^       +------------------+\n                            |                  ^\n                            |                  |\n* explicit prototype link --+                  | [__proto__]\n                                               |\n* implicit prototype link -------------------->|\n                                        +------+-----+\n                                        | New Object |\n                                        +------------+\n```\n\n此外，原型对象(NewObject.\\_\\_proto\\_\\_)也可以有一个它自己的隐式非空(non-null)原型引用(NewObject.\\_\\_proto\\_\\_.\\_\\_proto\\_\\_)，这样就形成一个原型链。当引用对象的某一个属性时，依次从这个对象和原型链上的原型对象的属性集合中找第一个包含此属性的对象，然后返回该属性值。\n在基于类的面向对象语言中，一般地，状态(属性值)由实例对象持有，方法由类持有，继承的只是结构(属性)和行为(方法)。而在javascript中，状态和方法都由对象持有。结构，行为，和状态都将被继承。\n对象并不直接包含原型链上共享出来的属性。\n\n### Definitions\n* Type：类型是数据值的集合\n* Primitive Value：原始值是Undefined/Null/Boolean/Number/String类型的值之一，是语言实现最底层的直接数据表示。\n* Object：对象是Object类型的值，是properties的无序集合，每个property都可以包含primitive value/object/function。存在于对象的property中的function又称为method(方法)。\n* Constructor：构造子(也即构造对象)是一个Function对象(通过Function这一构造子创建出来的对象)，用来创建和初始化新的对象。每一个构造子都有一个关联的prototype对象用来实现继承和共享属性。这里要明白的是，javascript中对象(通过new Object()创建，{}这种对象字面量只是new Object的一种简写方式)都是通过构造子，而自定义的构造子又是通过Function这一内置构造子生成出来的(即new Function()创建，function(){}这种函数字面量也只是new Function的一种简方式)。\n* Prototype：原型对象是用来实现继承结构，状态和行为的。当构造子创建一个对象时，新生成的对象会对构造子关联的原型对象有一个隐式引用(通过\\_\\_proto\\_\\_属性)，以便以后解析属性引用时使用。构造子关联的原型对象可以显式的通过Constructor.prototype来引用。原型对象添加的属性可以通过这种继承机制而被新生成的对象访问到。\n* Native/Built-in/Host Object：这些貌似不重要。\n* Undefined Type/Value：当一个变量并没有被赋值时，即为此种类型和值。这里存在一个歧义：即未定义的是变量还是变量的值？一种好的处理办法是，用undefined来表示变量为定义，而用null来表示值未定义。\n* Null Type/Value：表示null，空值，或者不存在的引用(规范上是这么写的。。)。\n* Boolean Type/Value\n* Boolean Object：Object类型的值，是内建Boolean对象的实例(即通过Boolean这一构造子new出来的)。可通过Boolean(b)来获取其布尔值。\n* String Type/Value：每个字符是16bit的UTF-16编码。\n* String Object：Object类型的值，是内建String对象的实例。可通过String(s)来获取字符串值。\n* Number Type/Value：能表示双精度64位格式的IEEE754规范的数字，包括NaN(`Not-a-Number`)及正无穷和负无穷。\n* Number Object：Object类型的值，是内建Number对象的实例。可通过Number(n)来获取值。\n* Infinity：Number类型的原始值，表示正无穷大。\n* NaN：Number类型的原始值，表示IEEE标准中的`Not-a-Number`集合的值。\n\n\n## Notational Conventions\n本节主要描述定义javascript词法和语法结构的上下文无关文法。\n\n### Context-Free Grammars\n上下文无关(Context-Free)文法由一些产生式(productions)组成。每个产生式由一个称为非终结符(nonterminal)的抽象符号作为左部分，一个由0个或多个非终结符和终结符(terminal)作为右部分构成。每条文法中的终结符都来自于一个有限的字符集合。词法分析产生语法分析的输入流，这里面包含词素(token)，即保留字/标识符/字面量/标点符。虽然换行符不是词素，但也包含在输入流中，用来指示自动插入`;`符号。注释的处理方式如下：\n\n* 单行注释(即以`//`开始)被直接抛弃(当然末尾的换行符被保留了)；\n* 多行注释(包含在`/* */`中)如果其中没有换行符则直接抛弃，否则用一个换行符替代；\n\n### Identifiers\n标识符的语法描述。\n    ReservedWord ::\n        Keyword\n        FutureReservedWord\n        NullLiteral\n        BooleanLiteral\n    Identifier ::\n    \tIdentifierName but not ReservedWord\n看见没有，根据这个描述，undefined/Infinity/NaN都是可以作为标识符的，其实，它们都是全局常量。\n\n\n## Types\n* Undefined/Null/Boolean/String/Number\n* Object。Property attributes:\n    * ReadOnly(用户代码的写操作被忽略，但宿主环境可以写)；\n    * DontEnum(for-in枚举表达式中不会被枚举出来)；\n    * DontDelete(删除Property的操作被忽略)；\n    * Internal(没有名字，因此也不能通过property accessor operator直接访问)；\n* Reference/List/Completion：这些类型的值只出现在表达式求值的中间结果中，不能保存到对象的属性中。\n\n### Internal Properties and Methods\n当Javascript的某种功能用到对象的Internal Property，而这个对象又没有实现这一Internal Property，则TypeError的异常将会抛出。\n有两种访问normal(non-internal) properties的方法：get/put操作，对应于retrieval和assignment。\nJavascript的native对象有一个叫\\[\\[Prototype\\]\\]的内部属性，它的值要么为null，要么为一个对象(用来实现继承，并且它的属性只支持读操作)。\n\n\n## Execution Contexts\n当Javascript函数对象代码开始执行时，execution context(执行上下文)就产生了，Active execution contexts逻辑上构建了一个栈，栈顶的execution context就是正在运行中的执行上下文。\n\n### Function Objects\n* 通过FunctionDeclaration语法定义，FunctionExpression语法或内建Function构造子动态创建的函数对象，将产生执行上下文；\n* 内建对象的internal functions，例如：parseInt/Math.exp等。这些函数对象并不包含Javascript可执行代码，它们并不产生execution context。\n\n### Types of Executable Code\n一共有3种Javascript可执行代码类型：\n\n* Global code：FunctionBody以外的source text。\n* Eval code：作为内建函数eval的字符串参数。\n* Function code：FunctionBody内的source text(不包含嵌套的FunctionBody)。\n\n### Variable Instantiation\n每一个execution context都有一个关联的variable object(简称VO)。一个execution context下的变量和函数声明都将作为properties添加到VO上。对于Function Code，参数也将作为properties添加到VO上。\n当进入一个execution context时，绑定到VO对象上的属性顺序如下：\n\n* 对于function code而言，会为相应VO对象创建与定义在FormalParameterList中的形参同名的属性，其值为caller调用[[Call]]时传递的实参。如果实参个数少于形参，则剩余的形参将被赋值为undefined。如果形参列表中存在同名时，则同名的VO属性值以最后一个形参的值为准。\n* 对于executable code中的FunctionDeclaration而言，执行上下文中的VO将会有一个与该函数声明中的标识符同名的属性，其值为声明的函数对象。如果VO中已经有同名的属性名，则用此值覆盖之前的。\n* 对于executable code中的VariableDeclaration而言，执行上下文中的VO将会有一个与该变量声明中的标识符同名的属性。如果VO中已经有同名的属性名，则该property的value和attributes保持不变。\n\n### Scope Chain and Identifier Resolution\n每个execution context都有一个关联的scope chain(作用域链)。作用域链是当标识符求值时查找的一组对象。当进入execution context时，作用域链就形成了。而在一个execution context中，其作用域链只被with和catch语句影响。标识符解析步骤：\n\n1. 获取作用域链的下一个对象，如果获取不到，则进入5；\n2. 调用Result(1)对象的[[HasProperty]]方法，并传递此标识符作为property；\n3. 若Result(2)为true，则返回一个引用类型的值，它的base object是Result(1)对象，属性名是此标识符；\n4. 否则，返回1继续；\n5. 返回一个引用类型的值，它的base object为null，属性名是此标识符。\n\n### Global Object\n有一个唯一的global object，在未进入任何execution context之前就创建了。它有以下属性：\n\n* 内建对象如：Math/String/Data/parseInt等，它们有DontEnum的attributes；\n* 额外的宿主定义的属性。可能包含一个属性，其值为全局对象自身。例如，在HTML文档对象模型中，全局对象的window属性就是全局对象自身；\n\n当进入到execution contexts中时，额外的属性可能会被追加到全局对象上，初始的属性也可能会改变。\n\n### Activation Object\n当进入到function code的execution context中时，一个称为Activation object(简称AO)就被创建了，并被关联到该execution contect上。这个AO有一个名为arguments的Property，且其有DontDelete的attribute。这个property的初始值是一个arguments object。\n这个AO接下来用来充作variable instantiation中的VO。\nAO只是一种机制，不可能通过javascript代码访问到这个对象(虽然可以访问到这个对象的成员)。当一个call操作被应用到一个base object为一个AO的引用类型的值的时候，这个call的this就被设置为null。\n\n### This\n当进入execution context时，该execution context会关联一个this值。并且在这个execution context中this值是不可变的。\n\n### Arguments Object\n当进入一个function code的execution context时，一个arguments object被创建并初始化：\n\n* Arguments Object的内部属性[[Prototype]]被设置为Object.prototype；\n* 一个名为callee的DontEnum属性被创建，它的初始值为当前执行的函数对象。有了这个属性，就可以实现匿名函数的递归了;\n* 一个名为length的DontEnum属性被创建，它的初始值为caller传递的实参个数；\n* 一个名为ToString(arg)的DontEnum属性被创建，它的初始值为caller传递的实参(arg=0表示第一个实参，访问方式为arguments[0])，这个属性与AO/VO中实参属性共享其值，它们能相互影响。\n\n\n## Entering An Execution Context\n每个函数和构造子调用都将进入一个新的execution context中，即使是一个递归的函数调用。每一个return都将退出一个execution context。一个没有捕获的异常抛出，可能会退出一个或多个execution context。\n当进入一个execution context时，scope chain就被创建并被初始化了，variable instanitiation也就完成了，并且this值也确定了。它们的初始化过程取决于执行的executable code类型。\n\n### Global Code\n* 作用域链被创建，并初始化为只包含global object；\n* Variable instantiation被执行：使用global object作为VO，并设置为DontDelete；\n* this值被设置为global object；\n\n### Eval Code\n当进入eval code的execution context时，先前的活跃active execution context(也被称为calling context)用来决定scope chain，variable object和this值。如果不存在calling context，那么初始化scope chain，variable object和this值的过程与global code一样，否则：\n\n* 作用域链按同样的顺序包含calling context的作用域链中的所有对象，这包括在calling context中通过with/catch语句追加到作用域链中的对象；\n* 使用calling context的VO对象来执行Variable instantiation过程，但清空property attributes；\n* this值设置为calling context的this值；\n\n### Function Code\n* scope chain初始化为包含AO，紧跟着的是当前Function object的[[Scope]]属性中保存的scope chain中的所有对象；\n* Variable instantiation执行：使用AO作为VO，并设置DontDelete；\n* 当caller的this值是对象时，则设置当前的this值为call的this值。否则设置当前的this值为global object；\n\n\n## Expressions\n\n## Statements\n\n## Function Definition\n\n## Native Javascript Objects\n\n在javascript程序执行前就已经存在一些内建对象了。其中一个就是global object，它存在于scope chain中。其它的作为global object的初始properties访问。\n如果内建对象有[[Call]]这一内部property，则它的[[Class]]属性值为\"Function\"，否则[[Class]]属性值为\"Object\"\n许多的内建对象同时也是函数(即函数对象)：它们可以被调用。这些函数对象中的某些还是constructors：可以用于new操作符。对于每个内建函数对象，规范描述了该函数调用时的形参及该对象的properties。对于每个内建constructor，规范还描述了其原型对象的properties及通过该构造子实例化出来的子对象的properties。\n如果一个函数或构造子调用时实参个数少于形参，那么剩下的形参被赋值为undefined。\n如果一个函数或构造子调用时实参个数多于形参，那么它的行为是未定义的。这种情况下，允许实现抛出一个TypeError的异常。\n每个内建函数对象(包括构造对象)都有Function的原型对象，即Function.prototype作为它们的[[Prototype]]属性值，eg：Function.\\_\\_proto\\_\\_==Function.prototype。\n每个内建原型对象都有Object的原型对象，即Object.prototype作为他们的[[Prototype]]属性值。eg：Function.prototype.\\_\\_proto\\_\\_ == Object.prototype。\n总结：函数对象的原型对象是Function.prototype；其他对象的原型对象是Object.prototype；而Object.prototype的原型对象为null(即Object.prototype.\\_\\_proto\\_\\_==null)。\n所有的内建非构造子函数对象都不会实现内部属性[[Construct]]方法及prototype属性。所有的内建函数对象都一个表示形参个数的{ReadOnly/DontDelete/DontEnum}的length属性。\n\n### The Global Object\n全局对象并没有[[Construct]]属性(否则就是构造子了)，所以不能对全局对象进行new操作。全局对象也没有[[Call]]属性(否则就是函数对象了)，所以全局对象不能作为函数来调用。\n全局对象的[[Prototype]]及[[Class]]属性值是依赖于实现的。\n\n#### Value Properties of the Global Object ####\n* NaN，初始值为NaN，{DontEnum, DontDelete}\n* Infinity，初始值为+o，{DontEnum，DontDelete}\n* undefined，初始值是undefined，{DontEnum，DontDelete}\n\n#### Function Properties of the Global Object ####\n* eval(x)\n* parseInt(string, radix)\n* parseFloat(string)\n* isNaN(number)\n* isFinite(number)\n\n#### URI Handling Function Properties ####\n* decodeURI(encodedURI)\n* decodeURIComponent(encodedURIComponent)\n* encodeURI(uri)\n* encodeURIComponent(uriComponent)\n\n#### Constructor Properties of the Global Object\n* Object\n* Function\n* Array\n* String\n* Boolean\n* Number\n* Date\n* RegExp\n* Error\n* EvalError\n* RangeError\n* ReferenceError\n* SyntaxError\n* TypeError\n* URIError","source":"_posts/2014-03-03-learn-ecma262-3rd-edition.md","raw":"---\ntitle: \"读一读 ECMA262 3rd edition\"\ndate: 2014/03/03 12:34:56\ncategories: javascript\n---\n\n## Overview\n\n### Web Scripting\nJavaScript是一种在宿主环境中执行计算和操作计算对象的面向对象编程语言。它起初被设计为一种Web scripting language，用来增加网页的交互性，以及执行一些服务端的计算。ECMAScript规范描述了其在宿主环境中的core scripting能力。\nWeb浏览器为javascript提供了作为客户端计算的宿主环境。它提供了一些对象用来表示windows, menus, pop-ups, dialog boxes, text areas, anchors, frames, history, cookies, 以及input/output。并且，这个宿主环境也提供了一种手段用来将scripting code绑定到一些事件上。例如，change of focus, page and image loading, unloading, error and abort, selection, form submission, 以及mouse actions。Scripting code嵌入在HTML代码当中，显示出来的页面由一些用户界面元素和一些固定位置并已计算好的文本和图像构成。Scripting code在用户的交互下会被触发执行，而不需要一个main程序去触发。\n而Web服务器为javascript提供了另一中作为服务端计算的宿主环境(如node.js)。它提供了一些对象用来表示requests, clients, 以及files。它也提供一种机制来锁住或共享数据。<!--more-->\n\n### Language Overview\nJavascript是基于对象的：语言基础和宿主环境的功能都以对象的方式提供，并且一个javascript程序就是一个由一些相互通信的对象组成的集合。一个javascript对象是一个由properties构成的无序集合。每一个prpperty包含0个或多个attributes，用来决定每个property怎样使用。例如，当一个property的ReadOnly attribute被设置为true的话，任何改变该property的值的操作都会失效。Property是一个容器，用来包含其它的对象：primitive values或者methods。一个原始值(primitive value)是以下内建类型的一个成员：Undefined, Null, Boolean, Number, String。而一个对象则是剩下的Object这一内建类型的一个成员。一个method是一个可以通过property关联到一个对象的function。\njavascript定义了一系列的内建对象，包括Global对象，Object对象，Function对象，Array对象，String对象，Boolean对象，Number对象，Math对象，Date对象，RegExp对象，和一些表示错误的对象(Error对象，EvalError对象，RangeError对象，ReferenceError对象，SyntaxError对象，TypeError对象，URIError对象)。\n\n### Objects\nJavascript并没有其它面向对象语言如C++，Smalltalk，Java等中的class机制来创建新的对象。但javascript有constructor这一构造对象，通过执行constructor的代码来为分配对象空间，并初始化对象空间的一些属性(properties)，从来产生新的对象。所有的constructor都是对象，但并不是所有的对象都是constructor。每一个constructor都有一个名为Prototype的属性(property)，用来实现基于原型的继承(prototype-based inheritance)和共享属性(shared properties)。对象通过在new表达式中使用constructor来创建。例如：new String(\"A String\")将创建一个新的String类型的对象。不使用new来调用constructor产生的效果将因constructor而异。例如：String(\"A String\")将产生一个String类型的原始值(primitive value)，而不会是String类型的对象。\n\nJavascript支持基于prototype的继承。每一个constructor都通过prototype属性来显式关联一个prototype对象。通过constructor对象构造新对象时，将以这个prototype对象为原型进行创建。新产生的对象对这个prototype对象会有一个隐式关联(通过\\_\\_proto\\_\\_属性关联)，通常这个隐式关联在程序中不可直接访问。\n\n这里一共涉及到三个对象。设有一个构造对象Constructor，那么：\n\n* 这个constructor显式关联一个prototype对象：Constructor.prototype(显式原型引用)；\n* 新产生的对象与原型对象有一个隐式引用：NewObject.\\_\\_proto\\_\\_(隐式原型引用)；\n\n```\n+--------------------+  [prototype] +------------------+\n| Constructor Object |+------------>| Prototype Object |\n+--------------------+      ^       +------------------+\n                            |                  ^\n                            |                  |\n* explicit prototype link --+                  | [__proto__]\n                                               |\n* implicit prototype link -------------------->|\n                                        +------+-----+\n                                        | New Object |\n                                        +------------+\n```\n\n此外，原型对象(NewObject.\\_\\_proto\\_\\_)也可以有一个它自己的隐式非空(non-null)原型引用(NewObject.\\_\\_proto\\_\\_.\\_\\_proto\\_\\_)，这样就形成一个原型链。当引用对象的某一个属性时，依次从这个对象和原型链上的原型对象的属性集合中找第一个包含此属性的对象，然后返回该属性值。\n在基于类的面向对象语言中，一般地，状态(属性值)由实例对象持有，方法由类持有，继承的只是结构(属性)和行为(方法)。而在javascript中，状态和方法都由对象持有。结构，行为，和状态都将被继承。\n对象并不直接包含原型链上共享出来的属性。\n\n### Definitions\n* Type：类型是数据值的集合\n* Primitive Value：原始值是Undefined/Null/Boolean/Number/String类型的值之一，是语言实现最底层的直接数据表示。\n* Object：对象是Object类型的值，是properties的无序集合，每个property都可以包含primitive value/object/function。存在于对象的property中的function又称为method(方法)。\n* Constructor：构造子(也即构造对象)是一个Function对象(通过Function这一构造子创建出来的对象)，用来创建和初始化新的对象。每一个构造子都有一个关联的prototype对象用来实现继承和共享属性。这里要明白的是，javascript中对象(通过new Object()创建，{}这种对象字面量只是new Object的一种简写方式)都是通过构造子，而自定义的构造子又是通过Function这一内置构造子生成出来的(即new Function()创建，function(){}这种函数字面量也只是new Function的一种简方式)。\n* Prototype：原型对象是用来实现继承结构，状态和行为的。当构造子创建一个对象时，新生成的对象会对构造子关联的原型对象有一个隐式引用(通过\\_\\_proto\\_\\_属性)，以便以后解析属性引用时使用。构造子关联的原型对象可以显式的通过Constructor.prototype来引用。原型对象添加的属性可以通过这种继承机制而被新生成的对象访问到。\n* Native/Built-in/Host Object：这些貌似不重要。\n* Undefined Type/Value：当一个变量并没有被赋值时，即为此种类型和值。这里存在一个歧义：即未定义的是变量还是变量的值？一种好的处理办法是，用undefined来表示变量为定义，而用null来表示值未定义。\n* Null Type/Value：表示null，空值，或者不存在的引用(规范上是这么写的。。)。\n* Boolean Type/Value\n* Boolean Object：Object类型的值，是内建Boolean对象的实例(即通过Boolean这一构造子new出来的)。可通过Boolean(b)来获取其布尔值。\n* String Type/Value：每个字符是16bit的UTF-16编码。\n* String Object：Object类型的值，是内建String对象的实例。可通过String(s)来获取字符串值。\n* Number Type/Value：能表示双精度64位格式的IEEE754规范的数字，包括NaN(`Not-a-Number`)及正无穷和负无穷。\n* Number Object：Object类型的值，是内建Number对象的实例。可通过Number(n)来获取值。\n* Infinity：Number类型的原始值，表示正无穷大。\n* NaN：Number类型的原始值，表示IEEE标准中的`Not-a-Number`集合的值。\n\n\n## Notational Conventions\n本节主要描述定义javascript词法和语法结构的上下文无关文法。\n\n### Context-Free Grammars\n上下文无关(Context-Free)文法由一些产生式(productions)组成。每个产生式由一个称为非终结符(nonterminal)的抽象符号作为左部分，一个由0个或多个非终结符和终结符(terminal)作为右部分构成。每条文法中的终结符都来自于一个有限的字符集合。词法分析产生语法分析的输入流，这里面包含词素(token)，即保留字/标识符/字面量/标点符。虽然换行符不是词素，但也包含在输入流中，用来指示自动插入`;`符号。注释的处理方式如下：\n\n* 单行注释(即以`//`开始)被直接抛弃(当然末尾的换行符被保留了)；\n* 多行注释(包含在`/* */`中)如果其中没有换行符则直接抛弃，否则用一个换行符替代；\n\n### Identifiers\n标识符的语法描述。\n    ReservedWord ::\n        Keyword\n        FutureReservedWord\n        NullLiteral\n        BooleanLiteral\n    Identifier ::\n    \tIdentifierName but not ReservedWord\n看见没有，根据这个描述，undefined/Infinity/NaN都是可以作为标识符的，其实，它们都是全局常量。\n\n\n## Types\n* Undefined/Null/Boolean/String/Number\n* Object。Property attributes:\n    * ReadOnly(用户代码的写操作被忽略，但宿主环境可以写)；\n    * DontEnum(for-in枚举表达式中不会被枚举出来)；\n    * DontDelete(删除Property的操作被忽略)；\n    * Internal(没有名字，因此也不能通过property accessor operator直接访问)；\n* Reference/List/Completion：这些类型的值只出现在表达式求值的中间结果中，不能保存到对象的属性中。\n\n### Internal Properties and Methods\n当Javascript的某种功能用到对象的Internal Property，而这个对象又没有实现这一Internal Property，则TypeError的异常将会抛出。\n有两种访问normal(non-internal) properties的方法：get/put操作，对应于retrieval和assignment。\nJavascript的native对象有一个叫\\[\\[Prototype\\]\\]的内部属性，它的值要么为null，要么为一个对象(用来实现继承，并且它的属性只支持读操作)。\n\n\n## Execution Contexts\n当Javascript函数对象代码开始执行时，execution context(执行上下文)就产生了，Active execution contexts逻辑上构建了一个栈，栈顶的execution context就是正在运行中的执行上下文。\n\n### Function Objects\n* 通过FunctionDeclaration语法定义，FunctionExpression语法或内建Function构造子动态创建的函数对象，将产生执行上下文；\n* 内建对象的internal functions，例如：parseInt/Math.exp等。这些函数对象并不包含Javascript可执行代码，它们并不产生execution context。\n\n### Types of Executable Code\n一共有3种Javascript可执行代码类型：\n\n* Global code：FunctionBody以外的source text。\n* Eval code：作为内建函数eval的字符串参数。\n* Function code：FunctionBody内的source text(不包含嵌套的FunctionBody)。\n\n### Variable Instantiation\n每一个execution context都有一个关联的variable object(简称VO)。一个execution context下的变量和函数声明都将作为properties添加到VO上。对于Function Code，参数也将作为properties添加到VO上。\n当进入一个execution context时，绑定到VO对象上的属性顺序如下：\n\n* 对于function code而言，会为相应VO对象创建与定义在FormalParameterList中的形参同名的属性，其值为caller调用[[Call]]时传递的实参。如果实参个数少于形参，则剩余的形参将被赋值为undefined。如果形参列表中存在同名时，则同名的VO属性值以最后一个形参的值为准。\n* 对于executable code中的FunctionDeclaration而言，执行上下文中的VO将会有一个与该函数声明中的标识符同名的属性，其值为声明的函数对象。如果VO中已经有同名的属性名，则用此值覆盖之前的。\n* 对于executable code中的VariableDeclaration而言，执行上下文中的VO将会有一个与该变量声明中的标识符同名的属性。如果VO中已经有同名的属性名，则该property的value和attributes保持不变。\n\n### Scope Chain and Identifier Resolution\n每个execution context都有一个关联的scope chain(作用域链)。作用域链是当标识符求值时查找的一组对象。当进入execution context时，作用域链就形成了。而在一个execution context中，其作用域链只被with和catch语句影响。标识符解析步骤：\n\n1. 获取作用域链的下一个对象，如果获取不到，则进入5；\n2. 调用Result(1)对象的[[HasProperty]]方法，并传递此标识符作为property；\n3. 若Result(2)为true，则返回一个引用类型的值，它的base object是Result(1)对象，属性名是此标识符；\n4. 否则，返回1继续；\n5. 返回一个引用类型的值，它的base object为null，属性名是此标识符。\n\n### Global Object\n有一个唯一的global object，在未进入任何execution context之前就创建了。它有以下属性：\n\n* 内建对象如：Math/String/Data/parseInt等，它们有DontEnum的attributes；\n* 额外的宿主定义的属性。可能包含一个属性，其值为全局对象自身。例如，在HTML文档对象模型中，全局对象的window属性就是全局对象自身；\n\n当进入到execution contexts中时，额外的属性可能会被追加到全局对象上，初始的属性也可能会改变。\n\n### Activation Object\n当进入到function code的execution context中时，一个称为Activation object(简称AO)就被创建了，并被关联到该execution contect上。这个AO有一个名为arguments的Property，且其有DontDelete的attribute。这个property的初始值是一个arguments object。\n这个AO接下来用来充作variable instantiation中的VO。\nAO只是一种机制，不可能通过javascript代码访问到这个对象(虽然可以访问到这个对象的成员)。当一个call操作被应用到一个base object为一个AO的引用类型的值的时候，这个call的this就被设置为null。\n\n### This\n当进入execution context时，该execution context会关联一个this值。并且在这个execution context中this值是不可变的。\n\n### Arguments Object\n当进入一个function code的execution context时，一个arguments object被创建并初始化：\n\n* Arguments Object的内部属性[[Prototype]]被设置为Object.prototype；\n* 一个名为callee的DontEnum属性被创建，它的初始值为当前执行的函数对象。有了这个属性，就可以实现匿名函数的递归了;\n* 一个名为length的DontEnum属性被创建，它的初始值为caller传递的实参个数；\n* 一个名为ToString(arg)的DontEnum属性被创建，它的初始值为caller传递的实参(arg=0表示第一个实参，访问方式为arguments[0])，这个属性与AO/VO中实参属性共享其值，它们能相互影响。\n\n\n## Entering An Execution Context\n每个函数和构造子调用都将进入一个新的execution context中，即使是一个递归的函数调用。每一个return都将退出一个execution context。一个没有捕获的异常抛出，可能会退出一个或多个execution context。\n当进入一个execution context时，scope chain就被创建并被初始化了，variable instanitiation也就完成了，并且this值也确定了。它们的初始化过程取决于执行的executable code类型。\n\n### Global Code\n* 作用域链被创建，并初始化为只包含global object；\n* Variable instantiation被执行：使用global object作为VO，并设置为DontDelete；\n* this值被设置为global object；\n\n### Eval Code\n当进入eval code的execution context时，先前的活跃active execution context(也被称为calling context)用来决定scope chain，variable object和this值。如果不存在calling context，那么初始化scope chain，variable object和this值的过程与global code一样，否则：\n\n* 作用域链按同样的顺序包含calling context的作用域链中的所有对象，这包括在calling context中通过with/catch语句追加到作用域链中的对象；\n* 使用calling context的VO对象来执行Variable instantiation过程，但清空property attributes；\n* this值设置为calling context的this值；\n\n### Function Code\n* scope chain初始化为包含AO，紧跟着的是当前Function object的[[Scope]]属性中保存的scope chain中的所有对象；\n* Variable instantiation执行：使用AO作为VO，并设置DontDelete；\n* 当caller的this值是对象时，则设置当前的this值为call的this值。否则设置当前的this值为global object；\n\n\n## Expressions\n\n## Statements\n\n## Function Definition\n\n## Native Javascript Objects\n\n在javascript程序执行前就已经存在一些内建对象了。其中一个就是global object，它存在于scope chain中。其它的作为global object的初始properties访问。\n如果内建对象有[[Call]]这一内部property，则它的[[Class]]属性值为\"Function\"，否则[[Class]]属性值为\"Object\"\n许多的内建对象同时也是函数(即函数对象)：它们可以被调用。这些函数对象中的某些还是constructors：可以用于new操作符。对于每个内建函数对象，规范描述了该函数调用时的形参及该对象的properties。对于每个内建constructor，规范还描述了其原型对象的properties及通过该构造子实例化出来的子对象的properties。\n如果一个函数或构造子调用时实参个数少于形参，那么剩下的形参被赋值为undefined。\n如果一个函数或构造子调用时实参个数多于形参，那么它的行为是未定义的。这种情况下，允许实现抛出一个TypeError的异常。\n每个内建函数对象(包括构造对象)都有Function的原型对象，即Function.prototype作为它们的[[Prototype]]属性值，eg：Function.\\_\\_proto\\_\\_==Function.prototype。\n每个内建原型对象都有Object的原型对象，即Object.prototype作为他们的[[Prototype]]属性值。eg：Function.prototype.\\_\\_proto\\_\\_ == Object.prototype。\n总结：函数对象的原型对象是Function.prototype；其他对象的原型对象是Object.prototype；而Object.prototype的原型对象为null(即Object.prototype.\\_\\_proto\\_\\_==null)。\n所有的内建非构造子函数对象都不会实现内部属性[[Construct]]方法及prototype属性。所有的内建函数对象都一个表示形参个数的{ReadOnly/DontDelete/DontEnum}的length属性。\n\n### The Global Object\n全局对象并没有[[Construct]]属性(否则就是构造子了)，所以不能对全局对象进行new操作。全局对象也没有[[Call]]属性(否则就是函数对象了)，所以全局对象不能作为函数来调用。\n全局对象的[[Prototype]]及[[Class]]属性值是依赖于实现的。\n\n#### Value Properties of the Global Object ####\n* NaN，初始值为NaN，{DontEnum, DontDelete}\n* Infinity，初始值为+o，{DontEnum，DontDelete}\n* undefined，初始值是undefined，{DontEnum，DontDelete}\n\n#### Function Properties of the Global Object ####\n* eval(x)\n* parseInt(string, radix)\n* parseFloat(string)\n* isNaN(number)\n* isFinite(number)\n\n#### URI Handling Function Properties ####\n* decodeURI(encodedURI)\n* decodeURIComponent(encodedURIComponent)\n* encodeURI(uri)\n* encodeURIComponent(uriComponent)\n\n#### Constructor Properties of the Global Object\n* Object\n* Function\n* Array\n* String\n* Boolean\n* Number\n* Date\n* RegExp\n* Error\n* EvalError\n* RangeError\n* ReferenceError\n* SyntaxError\n* TypeError\n* URIError","slug":"learn-ecma262-3rd-edition","published":1,"updated":"2017-12-26T11:21:51.776Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbnjnr9a0000v4tn50jkmdbo","content":"<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><h3 id=\"Web-Scripting\"><a href=\"#Web-Scripting\" class=\"headerlink\" title=\"Web Scripting\"></a>Web Scripting</h3><p>JavaScript是一种在宿主环境中执行计算和操作计算对象的面向对象编程语言。它起初被设计为一种Web scripting language，用来增加网页的交互性，以及执行一些服务端的计算。ECMAScript规范描述了其在宿主环境中的core scripting能力。<br>Web浏览器为javascript提供了作为客户端计算的宿主环境。它提供了一些对象用来表示windows, menus, pop-ups, dialog boxes, text areas, anchors, frames, history, cookies, 以及input/output。并且，这个宿主环境也提供了一种手段用来将scripting code绑定到一些事件上。例如，change of focus, page and image loading, unloading, error and abort, selection, form submission, 以及mouse actions。Scripting code嵌入在HTML代码当中，显示出来的页面由一些用户界面元素和一些固定位置并已计算好的文本和图像构成。Scripting code在用户的交互下会被触发执行，而不需要一个main程序去触发。<br>而Web服务器为javascript提供了另一中作为服务端计算的宿主环境(如node.js)。它提供了一些对象用来表示requests, clients, 以及files。它也提供一种机制来锁住或共享数据。<a id=\"more\"></a></p>\n<h3 id=\"Language-Overview\"><a href=\"#Language-Overview\" class=\"headerlink\" title=\"Language Overview\"></a>Language Overview</h3><p>Javascript是基于对象的：语言基础和宿主环境的功能都以对象的方式提供，并且一个javascript程序就是一个由一些相互通信的对象组成的集合。一个javascript对象是一个由properties构成的无序集合。每一个prpperty包含0个或多个attributes，用来决定每个property怎样使用。例如，当一个property的ReadOnly attribute被设置为true的话，任何改变该property的值的操作都会失效。Property是一个容器，用来包含其它的对象：primitive values或者methods。一个原始值(primitive value)是以下内建类型的一个成员：Undefined, Null, Boolean, Number, String。而一个对象则是剩下的Object这一内建类型的一个成员。一个method是一个可以通过property关联到一个对象的function。<br>javascript定义了一系列的内建对象，包括Global对象，Object对象，Function对象，Array对象，String对象，Boolean对象，Number对象，Math对象，Date对象，RegExp对象，和一些表示错误的对象(Error对象，EvalError对象，RangeError对象，ReferenceError对象，SyntaxError对象，TypeError对象，URIError对象)。</p>\n<h3 id=\"Objects\"><a href=\"#Objects\" class=\"headerlink\" title=\"Objects\"></a>Objects</h3><p>Javascript并没有其它面向对象语言如C++，Smalltalk，Java等中的class机制来创建新的对象。但javascript有constructor这一构造对象，通过执行constructor的代码来为分配对象空间，并初始化对象空间的一些属性(properties)，从来产生新的对象。所有的constructor都是对象，但并不是所有的对象都是constructor。每一个constructor都有一个名为Prototype的属性(property)，用来实现基于原型的继承(prototype-based inheritance)和共享属性(shared properties)。对象通过在new表达式中使用constructor来创建。例如：new String(“A String”)将创建一个新的String类型的对象。不使用new来调用constructor产生的效果将因constructor而异。例如：String(“A String”)将产生一个String类型的原始值(primitive value)，而不会是String类型的对象。</p>\n<p>Javascript支持基于prototype的继承。每一个constructor都通过prototype属性来显式关联一个prototype对象。通过constructor对象构造新对象时，将以这个prototype对象为原型进行创建。新产生的对象对这个prototype对象会有一个隐式关联(通过__proto__属性关联)，通常这个隐式关联在程序中不可直接访问。</p>\n<p>这里一共涉及到三个对象。设有一个构造对象Constructor，那么：</p>\n<ul>\n<li>这个constructor显式关联一个prototype对象：Constructor.prototype(显式原型引用)；</li>\n<li>新产生的对象与原型对象有一个隐式引用：NewObject.__proto__(隐式原型引用)；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--------------------+  [prototype] +------------------+</span><br><span class=\"line\">| Constructor Object |+------------&gt;| Prototype Object |</span><br><span class=\"line\">+--------------------+      ^       +------------------+</span><br><span class=\"line\">                            |                  ^</span><br><span class=\"line\">                            |                  |</span><br><span class=\"line\">* explicit prototype link --+                  | [__proto__]</span><br><span class=\"line\">                                               |</span><br><span class=\"line\">* implicit prototype link --------------------&gt;|</span><br><span class=\"line\">                                        +------+-----+</span><br><span class=\"line\">                                        | New Object |</span><br><span class=\"line\">                                        +------------+</span><br></pre></td></tr></table></figure>\n<p>此外，原型对象(NewObject.__proto__)也可以有一个它自己的隐式非空(non-null)原型引用(NewObject.__proto__.__proto__)，这样就形成一个原型链。当引用对象的某一个属性时，依次从这个对象和原型链上的原型对象的属性集合中找第一个包含此属性的对象，然后返回该属性值。<br>在基于类的面向对象语言中，一般地，状态(属性值)由实例对象持有，方法由类持有，继承的只是结构(属性)和行为(方法)。而在javascript中，状态和方法都由对象持有。结构，行为，和状态都将被继承。<br>对象并不直接包含原型链上共享出来的属性。</p>\n<h3 id=\"Definitions\"><a href=\"#Definitions\" class=\"headerlink\" title=\"Definitions\"></a>Definitions</h3><ul>\n<li>Type：类型是数据值的集合</li>\n<li>Primitive Value：原始值是Undefined/Null/Boolean/Number/String类型的值之一，是语言实现最底层的直接数据表示。</li>\n<li>Object：对象是Object类型的值，是properties的无序集合，每个property都可以包含primitive value/object/function。存在于对象的property中的function又称为method(方法)。</li>\n<li>Constructor：构造子(也即构造对象)是一个Function对象(通过Function这一构造子创建出来的对象)，用来创建和初始化新的对象。每一个构造子都有一个关联的prototype对象用来实现继承和共享属性。这里要明白的是，javascript中对象(通过new Object()创建，{}这种对象字面量只是new Object的一种简写方式)都是通过构造子，而自定义的构造子又是通过Function这一内置构造子生成出来的(即new Function()创建，function(){}这种函数字面量也只是new Function的一种简方式)。</li>\n<li>Prototype：原型对象是用来实现继承结构，状态和行为的。当构造子创建一个对象时，新生成的对象会对构造子关联的原型对象有一个隐式引用(通过__proto__属性)，以便以后解析属性引用时使用。构造子关联的原型对象可以显式的通过Constructor.prototype来引用。原型对象添加的属性可以通过这种继承机制而被新生成的对象访问到。</li>\n<li>Native/Built-in/Host Object：这些貌似不重要。</li>\n<li>Undefined Type/Value：当一个变量并没有被赋值时，即为此种类型和值。这里存在一个歧义：即未定义的是变量还是变量的值？一种好的处理办法是，用undefined来表示变量为定义，而用null来表示值未定义。</li>\n<li>Null Type/Value：表示null，空值，或者不存在的引用(规范上是这么写的。。)。</li>\n<li>Boolean Type/Value</li>\n<li>Boolean Object：Object类型的值，是内建Boolean对象的实例(即通过Boolean这一构造子new出来的)。可通过Boolean(b)来获取其布尔值。</li>\n<li>String Type/Value：每个字符是16bit的UTF-16编码。</li>\n<li>String Object：Object类型的值，是内建String对象的实例。可通过String(s)来获取字符串值。</li>\n<li>Number Type/Value：能表示双精度64位格式的IEEE754规范的数字，包括NaN(<code>Not-a-Number</code>)及正无穷和负无穷。</li>\n<li>Number Object：Object类型的值，是内建Number对象的实例。可通过Number(n)来获取值。</li>\n<li>Infinity：Number类型的原始值，表示正无穷大。</li>\n<li>NaN：Number类型的原始值，表示IEEE标准中的<code>Not-a-Number</code>集合的值。</li>\n</ul>\n<h2 id=\"Notational-Conventions\"><a href=\"#Notational-Conventions\" class=\"headerlink\" title=\"Notational Conventions\"></a>Notational Conventions</h2><p>本节主要描述定义javascript词法和语法结构的上下文无关文法。</p>\n<h3 id=\"Context-Free-Grammars\"><a href=\"#Context-Free-Grammars\" class=\"headerlink\" title=\"Context-Free Grammars\"></a>Context-Free Grammars</h3><p>上下文无关(Context-Free)文法由一些产生式(productions)组成。每个产生式由一个称为非终结符(nonterminal)的抽象符号作为左部分，一个由0个或多个非终结符和终结符(terminal)作为右部分构成。每条文法中的终结符都来自于一个有限的字符集合。词法分析产生语法分析的输入流，这里面包含词素(token)，即保留字/标识符/字面量/标点符。虽然换行符不是词素，但也包含在输入流中，用来指示自动插入<code>;</code>符号。注释的处理方式如下：</p>\n<ul>\n<li>单行注释(即以<code>//</code>开始)被直接抛弃(当然末尾的换行符被保留了)；</li>\n<li>多行注释(包含在<code>/* */</code>中)如果其中没有换行符则直接抛弃，否则用一个换行符替代；</li>\n</ul>\n<h3 id=\"Identifiers\"><a href=\"#Identifiers\" class=\"headerlink\" title=\"Identifiers\"></a>Identifiers</h3><p>标识符的语法描述。<br>    ReservedWord ::<br>        Keyword<br>        FutureReservedWord<br>        NullLiteral<br>        BooleanLiteral<br>    Identifier ::<br>        IdentifierName but not ReservedWord<br>看见没有，根据这个描述，undefined/Infinity/NaN都是可以作为标识符的，其实，它们都是全局常量。</p>\n<h2 id=\"Types\"><a href=\"#Types\" class=\"headerlink\" title=\"Types\"></a>Types</h2><ul>\n<li>Undefined/Null/Boolean/String/Number</li>\n<li>Object。Property attributes:<ul>\n<li>ReadOnly(用户代码的写操作被忽略，但宿主环境可以写)；</li>\n<li>DontEnum(for-in枚举表达式中不会被枚举出来)；</li>\n<li>DontDelete(删除Property的操作被忽略)；</li>\n<li>Internal(没有名字，因此也不能通过property accessor operator直接访问)；</li>\n</ul>\n</li>\n<li>Reference/List/Completion：这些类型的值只出现在表达式求值的中间结果中，不能保存到对象的属性中。</li>\n</ul>\n<h3 id=\"Internal-Properties-and-Methods\"><a href=\"#Internal-Properties-and-Methods\" class=\"headerlink\" title=\"Internal Properties and Methods\"></a>Internal Properties and Methods</h3><p>当Javascript的某种功能用到对象的Internal Property，而这个对象又没有实现这一Internal Property，则TypeError的异常将会抛出。<br>有两种访问normal(non-internal) properties的方法：get/put操作，对应于retrieval和assignment。<br>Javascript的native对象有一个叫[[Prototype]]的内部属性，它的值要么为null，要么为一个对象(用来实现继承，并且它的属性只支持读操作)。</p>\n<h2 id=\"Execution-Contexts\"><a href=\"#Execution-Contexts\" class=\"headerlink\" title=\"Execution Contexts\"></a>Execution Contexts</h2><p>当Javascript函数对象代码开始执行时，execution context(执行上下文)就产生了，Active execution contexts逻辑上构建了一个栈，栈顶的execution context就是正在运行中的执行上下文。</p>\n<h3 id=\"Function-Objects\"><a href=\"#Function-Objects\" class=\"headerlink\" title=\"Function Objects\"></a>Function Objects</h3><ul>\n<li>通过FunctionDeclaration语法定义，FunctionExpression语法或内建Function构造子动态创建的函数对象，将产生执行上下文；</li>\n<li>内建对象的internal functions，例如：parseInt/Math.exp等。这些函数对象并不包含Javascript可执行代码，它们并不产生execution context。</li>\n</ul>\n<h3 id=\"Types-of-Executable-Code\"><a href=\"#Types-of-Executable-Code\" class=\"headerlink\" title=\"Types of Executable Code\"></a>Types of Executable Code</h3><p>一共有3种Javascript可执行代码类型：</p>\n<ul>\n<li>Global code：FunctionBody以外的source text。</li>\n<li>Eval code：作为内建函数eval的字符串参数。</li>\n<li>Function code：FunctionBody内的source text(不包含嵌套的FunctionBody)。</li>\n</ul>\n<h3 id=\"Variable-Instantiation\"><a href=\"#Variable-Instantiation\" class=\"headerlink\" title=\"Variable Instantiation\"></a>Variable Instantiation</h3><p>每一个execution context都有一个关联的variable object(简称VO)。一个execution context下的变量和函数声明都将作为properties添加到VO上。对于Function Code，参数也将作为properties添加到VO上。<br>当进入一个execution context时，绑定到VO对象上的属性顺序如下：</p>\n<ul>\n<li>对于function code而言，会为相应VO对象创建与定义在FormalParameterList中的形参同名的属性，其值为caller调用[[Call]]时传递的实参。如果实参个数少于形参，则剩余的形参将被赋值为undefined。如果形参列表中存在同名时，则同名的VO属性值以最后一个形参的值为准。</li>\n<li>对于executable code中的FunctionDeclaration而言，执行上下文中的VO将会有一个与该函数声明中的标识符同名的属性，其值为声明的函数对象。如果VO中已经有同名的属性名，则用此值覆盖之前的。</li>\n<li>对于executable code中的VariableDeclaration而言，执行上下文中的VO将会有一个与该变量声明中的标识符同名的属性。如果VO中已经有同名的属性名，则该property的value和attributes保持不变。</li>\n</ul>\n<h3 id=\"Scope-Chain-and-Identifier-Resolution\"><a href=\"#Scope-Chain-and-Identifier-Resolution\" class=\"headerlink\" title=\"Scope Chain and Identifier Resolution\"></a>Scope Chain and Identifier Resolution</h3><p>每个execution context都有一个关联的scope chain(作用域链)。作用域链是当标识符求值时查找的一组对象。当进入execution context时，作用域链就形成了。而在一个execution context中，其作用域链只被with和catch语句影响。标识符解析步骤：</p>\n<ol>\n<li>获取作用域链的下一个对象，如果获取不到，则进入5；</li>\n<li>调用Result(1)对象的[[HasProperty]]方法，并传递此标识符作为property；</li>\n<li>若Result(2)为true，则返回一个引用类型的值，它的base object是Result(1)对象，属性名是此标识符；</li>\n<li>否则，返回1继续；</li>\n<li>返回一个引用类型的值，它的base object为null，属性名是此标识符。</li>\n</ol>\n<h3 id=\"Global-Object\"><a href=\"#Global-Object\" class=\"headerlink\" title=\"Global Object\"></a>Global Object</h3><p>有一个唯一的global object，在未进入任何execution context之前就创建了。它有以下属性：</p>\n<ul>\n<li>内建对象如：Math/String/Data/parseInt等，它们有DontEnum的attributes；</li>\n<li>额外的宿主定义的属性。可能包含一个属性，其值为全局对象自身。例如，在HTML文档对象模型中，全局对象的window属性就是全局对象自身；</li>\n</ul>\n<p>当进入到execution contexts中时，额外的属性可能会被追加到全局对象上，初始的属性也可能会改变。</p>\n<h3 id=\"Activation-Object\"><a href=\"#Activation-Object\" class=\"headerlink\" title=\"Activation Object\"></a>Activation Object</h3><p>当进入到function code的execution context中时，一个称为Activation object(简称AO)就被创建了，并被关联到该execution contect上。这个AO有一个名为arguments的Property，且其有DontDelete的attribute。这个property的初始值是一个arguments object。<br>这个AO接下来用来充作variable instantiation中的VO。<br>AO只是一种机制，不可能通过javascript代码访问到这个对象(虽然可以访问到这个对象的成员)。当一个call操作被应用到一个base object为一个AO的引用类型的值的时候，这个call的this就被设置为null。</p>\n<h3 id=\"This\"><a href=\"#This\" class=\"headerlink\" title=\"This\"></a>This</h3><p>当进入execution context时，该execution context会关联一个this值。并且在这个execution context中this值是不可变的。</p>\n<h3 id=\"Arguments-Object\"><a href=\"#Arguments-Object\" class=\"headerlink\" title=\"Arguments Object\"></a>Arguments Object</h3><p>当进入一个function code的execution context时，一个arguments object被创建并初始化：</p>\n<ul>\n<li>Arguments Object的内部属性[[Prototype]]被设置为Object.prototype；</li>\n<li>一个名为callee的DontEnum属性被创建，它的初始值为当前执行的函数对象。有了这个属性，就可以实现匿名函数的递归了;</li>\n<li>一个名为length的DontEnum属性被创建，它的初始值为caller传递的实参个数；</li>\n<li>一个名为ToString(arg)的DontEnum属性被创建，它的初始值为caller传递的实参(arg=0表示第一个实参，访问方式为arguments[0])，这个属性与AO/VO中实参属性共享其值，它们能相互影响。</li>\n</ul>\n<h2 id=\"Entering-An-Execution-Context\"><a href=\"#Entering-An-Execution-Context\" class=\"headerlink\" title=\"Entering An Execution Context\"></a>Entering An Execution Context</h2><p>每个函数和构造子调用都将进入一个新的execution context中，即使是一个递归的函数调用。每一个return都将退出一个execution context。一个没有捕获的异常抛出，可能会退出一个或多个execution context。<br>当进入一个execution context时，scope chain就被创建并被初始化了，variable instanitiation也就完成了，并且this值也确定了。它们的初始化过程取决于执行的executable code类型。</p>\n<h3 id=\"Global-Code\"><a href=\"#Global-Code\" class=\"headerlink\" title=\"Global Code\"></a>Global Code</h3><ul>\n<li>作用域链被创建，并初始化为只包含global object；</li>\n<li>Variable instantiation被执行：使用global object作为VO，并设置为DontDelete；</li>\n<li>this值被设置为global object；</li>\n</ul>\n<h3 id=\"Eval-Code\"><a href=\"#Eval-Code\" class=\"headerlink\" title=\"Eval Code\"></a>Eval Code</h3><p>当进入eval code的execution context时，先前的活跃active execution context(也被称为calling context)用来决定scope chain，variable object和this值。如果不存在calling context，那么初始化scope chain，variable object和this值的过程与global code一样，否则：</p>\n<ul>\n<li>作用域链按同样的顺序包含calling context的作用域链中的所有对象，这包括在calling context中通过with/catch语句追加到作用域链中的对象；</li>\n<li>使用calling context的VO对象来执行Variable instantiation过程，但清空property attributes；</li>\n<li>this值设置为calling context的this值；</li>\n</ul>\n<h3 id=\"Function-Code\"><a href=\"#Function-Code\" class=\"headerlink\" title=\"Function Code\"></a>Function Code</h3><ul>\n<li>scope chain初始化为包含AO，紧跟着的是当前Function object的[[Scope]]属性中保存的scope chain中的所有对象；</li>\n<li>Variable instantiation执行：使用AO作为VO，并设置DontDelete；</li>\n<li>当caller的this值是对象时，则设置当前的this值为call的this值。否则设置当前的this值为global object；</li>\n</ul>\n<h2 id=\"Expressions\"><a href=\"#Expressions\" class=\"headerlink\" title=\"Expressions\"></a>Expressions</h2><h2 id=\"Statements\"><a href=\"#Statements\" class=\"headerlink\" title=\"Statements\"></a>Statements</h2><h2 id=\"Function-Definition\"><a href=\"#Function-Definition\" class=\"headerlink\" title=\"Function Definition\"></a>Function Definition</h2><h2 id=\"Native-Javascript-Objects\"><a href=\"#Native-Javascript-Objects\" class=\"headerlink\" title=\"Native Javascript Objects\"></a>Native Javascript Objects</h2><p>在javascript程序执行前就已经存在一些内建对象了。其中一个就是global object，它存在于scope chain中。其它的作为global object的初始properties访问。<br>如果内建对象有[[Call]]这一内部property，则它的[[Class]]属性值为”Function”，否则[[Class]]属性值为”Object”<br>许多的内建对象同时也是函数(即函数对象)：它们可以被调用。这些函数对象中的某些还是constructors：可以用于new操作符。对于每个内建函数对象，规范描述了该函数调用时的形参及该对象的properties。对于每个内建constructor，规范还描述了其原型对象的properties及通过该构造子实例化出来的子对象的properties。<br>如果一个函数或构造子调用时实参个数少于形参，那么剩下的形参被赋值为undefined。<br>如果一个函数或构造子调用时实参个数多于形参，那么它的行为是未定义的。这种情况下，允许实现抛出一个TypeError的异常。<br>每个内建函数对象(包括构造对象)都有Function的原型对象，即Function.prototype作为它们的[[Prototype]]属性值，eg：Function.__proto__==Function.prototype。<br>每个内建原型对象都有Object的原型对象，即Object.prototype作为他们的[[Prototype]]属性值。eg：Function.prototype.__proto__ == Object.prototype。<br>总结：函数对象的原型对象是Function.prototype；其他对象的原型对象是Object.prototype；而Object.prototype的原型对象为null(即Object.prototype.__proto__==null)。<br>所有的内建非构造子函数对象都不会实现内部属性[[Construct]]方法及prototype属性。所有的内建函数对象都一个表示形参个数的{ReadOnly/DontDelete/DontEnum}的length属性。</p>\n<h3 id=\"The-Global-Object\"><a href=\"#The-Global-Object\" class=\"headerlink\" title=\"The Global Object\"></a>The Global Object</h3><p>全局对象并没有[[Construct]]属性(否则就是构造子了)，所以不能对全局对象进行new操作。全局对象也没有[[Call]]属性(否则就是函数对象了)，所以全局对象不能作为函数来调用。<br>全局对象的[[Prototype]]及[[Class]]属性值是依赖于实现的。</p>\n<h4 id=\"Value-Properties-of-the-Global-Object\"><a href=\"#Value-Properties-of-the-Global-Object\" class=\"headerlink\" title=\"Value Properties of the Global Object\"></a>Value Properties of the Global Object</h4><ul>\n<li>NaN，初始值为NaN，{DontEnum, DontDelete}</li>\n<li>Infinity，初始值为+o，{DontEnum，DontDelete}</li>\n<li>undefined，初始值是undefined，{DontEnum，DontDelete}</li>\n</ul>\n<h4 id=\"Function-Properties-of-the-Global-Object\"><a href=\"#Function-Properties-of-the-Global-Object\" class=\"headerlink\" title=\"Function Properties of the Global Object\"></a>Function Properties of the Global Object</h4><ul>\n<li>eval(x)</li>\n<li>parseInt(string, radix)</li>\n<li>parseFloat(string)</li>\n<li>isNaN(number)</li>\n<li>isFinite(number)</li>\n</ul>\n<h4 id=\"URI-Handling-Function-Properties\"><a href=\"#URI-Handling-Function-Properties\" class=\"headerlink\" title=\"URI Handling Function Properties\"></a>URI Handling Function Properties</h4><ul>\n<li>decodeURI(encodedURI)</li>\n<li>decodeURIComponent(encodedURIComponent)</li>\n<li>encodeURI(uri)</li>\n<li>encodeURIComponent(uriComponent)</li>\n</ul>\n<h4 id=\"Constructor-Properties-of-the-Global-Object\"><a href=\"#Constructor-Properties-of-the-Global-Object\" class=\"headerlink\" title=\"Constructor Properties of the Global Object\"></a>Constructor Properties of the Global Object</h4><ul>\n<li>Object</li>\n<li>Function</li>\n<li>Array</li>\n<li>String</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n<li>EvalError</li>\n<li>RangeError</li>\n<li>ReferenceError</li>\n<li>SyntaxError</li>\n<li>TypeError</li>\n<li>URIError</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><h3 id=\"Web-Scripting\"><a href=\"#Web-Scripting\" class=\"headerlink\" title=\"Web Scripting\"></a>Web Scripting</h3><p>JavaScript是一种在宿主环境中执行计算和操作计算对象的面向对象编程语言。它起初被设计为一种Web scripting language，用来增加网页的交互性，以及执行一些服务端的计算。ECMAScript规范描述了其在宿主环境中的core scripting能力。<br>Web浏览器为javascript提供了作为客户端计算的宿主环境。它提供了一些对象用来表示windows, menus, pop-ups, dialog boxes, text areas, anchors, frames, history, cookies, 以及input/output。并且，这个宿主环境也提供了一种手段用来将scripting code绑定到一些事件上。例如，change of focus, page and image loading, unloading, error and abort, selection, form submission, 以及mouse actions。Scripting code嵌入在HTML代码当中，显示出来的页面由一些用户界面元素和一些固定位置并已计算好的文本和图像构成。Scripting code在用户的交互下会被触发执行，而不需要一个main程序去触发。<br>而Web服务器为javascript提供了另一中作为服务端计算的宿主环境(如node.js)。它提供了一些对象用来表示requests, clients, 以及files。它也提供一种机制来锁住或共享数据。","more":"</p>\n<h3 id=\"Language-Overview\"><a href=\"#Language-Overview\" class=\"headerlink\" title=\"Language Overview\"></a>Language Overview</h3><p>Javascript是基于对象的：语言基础和宿主环境的功能都以对象的方式提供，并且一个javascript程序就是一个由一些相互通信的对象组成的集合。一个javascript对象是一个由properties构成的无序集合。每一个prpperty包含0个或多个attributes，用来决定每个property怎样使用。例如，当一个property的ReadOnly attribute被设置为true的话，任何改变该property的值的操作都会失效。Property是一个容器，用来包含其它的对象：primitive values或者methods。一个原始值(primitive value)是以下内建类型的一个成员：Undefined, Null, Boolean, Number, String。而一个对象则是剩下的Object这一内建类型的一个成员。一个method是一个可以通过property关联到一个对象的function。<br>javascript定义了一系列的内建对象，包括Global对象，Object对象，Function对象，Array对象，String对象，Boolean对象，Number对象，Math对象，Date对象，RegExp对象，和一些表示错误的对象(Error对象，EvalError对象，RangeError对象，ReferenceError对象，SyntaxError对象，TypeError对象，URIError对象)。</p>\n<h3 id=\"Objects\"><a href=\"#Objects\" class=\"headerlink\" title=\"Objects\"></a>Objects</h3><p>Javascript并没有其它面向对象语言如C++，Smalltalk，Java等中的class机制来创建新的对象。但javascript有constructor这一构造对象，通过执行constructor的代码来为分配对象空间，并初始化对象空间的一些属性(properties)，从来产生新的对象。所有的constructor都是对象，但并不是所有的对象都是constructor。每一个constructor都有一个名为Prototype的属性(property)，用来实现基于原型的继承(prototype-based inheritance)和共享属性(shared properties)。对象通过在new表达式中使用constructor来创建。例如：new String(“A String”)将创建一个新的String类型的对象。不使用new来调用constructor产生的效果将因constructor而异。例如：String(“A String”)将产生一个String类型的原始值(primitive value)，而不会是String类型的对象。</p>\n<p>Javascript支持基于prototype的继承。每一个constructor都通过prototype属性来显式关联一个prototype对象。通过constructor对象构造新对象时，将以这个prototype对象为原型进行创建。新产生的对象对这个prototype对象会有一个隐式关联(通过__proto__属性关联)，通常这个隐式关联在程序中不可直接访问。</p>\n<p>这里一共涉及到三个对象。设有一个构造对象Constructor，那么：</p>\n<ul>\n<li>这个constructor显式关联一个prototype对象：Constructor.prototype(显式原型引用)；</li>\n<li>新产生的对象与原型对象有一个隐式引用：NewObject.__proto__(隐式原型引用)；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--------------------+  [prototype] +------------------+</span><br><span class=\"line\">| Constructor Object |+------------&gt;| Prototype Object |</span><br><span class=\"line\">+--------------------+      ^       +------------------+</span><br><span class=\"line\">                            |                  ^</span><br><span class=\"line\">                            |                  |</span><br><span class=\"line\">* explicit prototype link --+                  | [__proto__]</span><br><span class=\"line\">                                               |</span><br><span class=\"line\">* implicit prototype link --------------------&gt;|</span><br><span class=\"line\">                                        +------+-----+</span><br><span class=\"line\">                                        | New Object |</span><br><span class=\"line\">                                        +------------+</span><br></pre></td></tr></table></figure>\n<p>此外，原型对象(NewObject.__proto__)也可以有一个它自己的隐式非空(non-null)原型引用(NewObject.__proto__.__proto__)，这样就形成一个原型链。当引用对象的某一个属性时，依次从这个对象和原型链上的原型对象的属性集合中找第一个包含此属性的对象，然后返回该属性值。<br>在基于类的面向对象语言中，一般地，状态(属性值)由实例对象持有，方法由类持有，继承的只是结构(属性)和行为(方法)。而在javascript中，状态和方法都由对象持有。结构，行为，和状态都将被继承。<br>对象并不直接包含原型链上共享出来的属性。</p>\n<h3 id=\"Definitions\"><a href=\"#Definitions\" class=\"headerlink\" title=\"Definitions\"></a>Definitions</h3><ul>\n<li>Type：类型是数据值的集合</li>\n<li>Primitive Value：原始值是Undefined/Null/Boolean/Number/String类型的值之一，是语言实现最底层的直接数据表示。</li>\n<li>Object：对象是Object类型的值，是properties的无序集合，每个property都可以包含primitive value/object/function。存在于对象的property中的function又称为method(方法)。</li>\n<li>Constructor：构造子(也即构造对象)是一个Function对象(通过Function这一构造子创建出来的对象)，用来创建和初始化新的对象。每一个构造子都有一个关联的prototype对象用来实现继承和共享属性。这里要明白的是，javascript中对象(通过new Object()创建，{}这种对象字面量只是new Object的一种简写方式)都是通过构造子，而自定义的构造子又是通过Function这一内置构造子生成出来的(即new Function()创建，function(){}这种函数字面量也只是new Function的一种简方式)。</li>\n<li>Prototype：原型对象是用来实现继承结构，状态和行为的。当构造子创建一个对象时，新生成的对象会对构造子关联的原型对象有一个隐式引用(通过__proto__属性)，以便以后解析属性引用时使用。构造子关联的原型对象可以显式的通过Constructor.prototype来引用。原型对象添加的属性可以通过这种继承机制而被新生成的对象访问到。</li>\n<li>Native/Built-in/Host Object：这些貌似不重要。</li>\n<li>Undefined Type/Value：当一个变量并没有被赋值时，即为此种类型和值。这里存在一个歧义：即未定义的是变量还是变量的值？一种好的处理办法是，用undefined来表示变量为定义，而用null来表示值未定义。</li>\n<li>Null Type/Value：表示null，空值，或者不存在的引用(规范上是这么写的。。)。</li>\n<li>Boolean Type/Value</li>\n<li>Boolean Object：Object类型的值，是内建Boolean对象的实例(即通过Boolean这一构造子new出来的)。可通过Boolean(b)来获取其布尔值。</li>\n<li>String Type/Value：每个字符是16bit的UTF-16编码。</li>\n<li>String Object：Object类型的值，是内建String对象的实例。可通过String(s)来获取字符串值。</li>\n<li>Number Type/Value：能表示双精度64位格式的IEEE754规范的数字，包括NaN(<code>Not-a-Number</code>)及正无穷和负无穷。</li>\n<li>Number Object：Object类型的值，是内建Number对象的实例。可通过Number(n)来获取值。</li>\n<li>Infinity：Number类型的原始值，表示正无穷大。</li>\n<li>NaN：Number类型的原始值，表示IEEE标准中的<code>Not-a-Number</code>集合的值。</li>\n</ul>\n<h2 id=\"Notational-Conventions\"><a href=\"#Notational-Conventions\" class=\"headerlink\" title=\"Notational Conventions\"></a>Notational Conventions</h2><p>本节主要描述定义javascript词法和语法结构的上下文无关文法。</p>\n<h3 id=\"Context-Free-Grammars\"><a href=\"#Context-Free-Grammars\" class=\"headerlink\" title=\"Context-Free Grammars\"></a>Context-Free Grammars</h3><p>上下文无关(Context-Free)文法由一些产生式(productions)组成。每个产生式由一个称为非终结符(nonterminal)的抽象符号作为左部分，一个由0个或多个非终结符和终结符(terminal)作为右部分构成。每条文法中的终结符都来自于一个有限的字符集合。词法分析产生语法分析的输入流，这里面包含词素(token)，即保留字/标识符/字面量/标点符。虽然换行符不是词素，但也包含在输入流中，用来指示自动插入<code>;</code>符号。注释的处理方式如下：</p>\n<ul>\n<li>单行注释(即以<code>//</code>开始)被直接抛弃(当然末尾的换行符被保留了)；</li>\n<li>多行注释(包含在<code>/* */</code>中)如果其中没有换行符则直接抛弃，否则用一个换行符替代；</li>\n</ul>\n<h3 id=\"Identifiers\"><a href=\"#Identifiers\" class=\"headerlink\" title=\"Identifiers\"></a>Identifiers</h3><p>标识符的语法描述。<br>    ReservedWord ::<br>        Keyword<br>        FutureReservedWord<br>        NullLiteral<br>        BooleanLiteral<br>    Identifier ::<br>        IdentifierName but not ReservedWord<br>看见没有，根据这个描述，undefined/Infinity/NaN都是可以作为标识符的，其实，它们都是全局常量。</p>\n<h2 id=\"Types\"><a href=\"#Types\" class=\"headerlink\" title=\"Types\"></a>Types</h2><ul>\n<li>Undefined/Null/Boolean/String/Number</li>\n<li>Object。Property attributes:<ul>\n<li>ReadOnly(用户代码的写操作被忽略，但宿主环境可以写)；</li>\n<li>DontEnum(for-in枚举表达式中不会被枚举出来)；</li>\n<li>DontDelete(删除Property的操作被忽略)；</li>\n<li>Internal(没有名字，因此也不能通过property accessor operator直接访问)；</li>\n</ul>\n</li>\n<li>Reference/List/Completion：这些类型的值只出现在表达式求值的中间结果中，不能保存到对象的属性中。</li>\n</ul>\n<h3 id=\"Internal-Properties-and-Methods\"><a href=\"#Internal-Properties-and-Methods\" class=\"headerlink\" title=\"Internal Properties and Methods\"></a>Internal Properties and Methods</h3><p>当Javascript的某种功能用到对象的Internal Property，而这个对象又没有实现这一Internal Property，则TypeError的异常将会抛出。<br>有两种访问normal(non-internal) properties的方法：get/put操作，对应于retrieval和assignment。<br>Javascript的native对象有一个叫[[Prototype]]的内部属性，它的值要么为null，要么为一个对象(用来实现继承，并且它的属性只支持读操作)。</p>\n<h2 id=\"Execution-Contexts\"><a href=\"#Execution-Contexts\" class=\"headerlink\" title=\"Execution Contexts\"></a>Execution Contexts</h2><p>当Javascript函数对象代码开始执行时，execution context(执行上下文)就产生了，Active execution contexts逻辑上构建了一个栈，栈顶的execution context就是正在运行中的执行上下文。</p>\n<h3 id=\"Function-Objects\"><a href=\"#Function-Objects\" class=\"headerlink\" title=\"Function Objects\"></a>Function Objects</h3><ul>\n<li>通过FunctionDeclaration语法定义，FunctionExpression语法或内建Function构造子动态创建的函数对象，将产生执行上下文；</li>\n<li>内建对象的internal functions，例如：parseInt/Math.exp等。这些函数对象并不包含Javascript可执行代码，它们并不产生execution context。</li>\n</ul>\n<h3 id=\"Types-of-Executable-Code\"><a href=\"#Types-of-Executable-Code\" class=\"headerlink\" title=\"Types of Executable Code\"></a>Types of Executable Code</h3><p>一共有3种Javascript可执行代码类型：</p>\n<ul>\n<li>Global code：FunctionBody以外的source text。</li>\n<li>Eval code：作为内建函数eval的字符串参数。</li>\n<li>Function code：FunctionBody内的source text(不包含嵌套的FunctionBody)。</li>\n</ul>\n<h3 id=\"Variable-Instantiation\"><a href=\"#Variable-Instantiation\" class=\"headerlink\" title=\"Variable Instantiation\"></a>Variable Instantiation</h3><p>每一个execution context都有一个关联的variable object(简称VO)。一个execution context下的变量和函数声明都将作为properties添加到VO上。对于Function Code，参数也将作为properties添加到VO上。<br>当进入一个execution context时，绑定到VO对象上的属性顺序如下：</p>\n<ul>\n<li>对于function code而言，会为相应VO对象创建与定义在FormalParameterList中的形参同名的属性，其值为caller调用[[Call]]时传递的实参。如果实参个数少于形参，则剩余的形参将被赋值为undefined。如果形参列表中存在同名时，则同名的VO属性值以最后一个形参的值为准。</li>\n<li>对于executable code中的FunctionDeclaration而言，执行上下文中的VO将会有一个与该函数声明中的标识符同名的属性，其值为声明的函数对象。如果VO中已经有同名的属性名，则用此值覆盖之前的。</li>\n<li>对于executable code中的VariableDeclaration而言，执行上下文中的VO将会有一个与该变量声明中的标识符同名的属性。如果VO中已经有同名的属性名，则该property的value和attributes保持不变。</li>\n</ul>\n<h3 id=\"Scope-Chain-and-Identifier-Resolution\"><a href=\"#Scope-Chain-and-Identifier-Resolution\" class=\"headerlink\" title=\"Scope Chain and Identifier Resolution\"></a>Scope Chain and Identifier Resolution</h3><p>每个execution context都有一个关联的scope chain(作用域链)。作用域链是当标识符求值时查找的一组对象。当进入execution context时，作用域链就形成了。而在一个execution context中，其作用域链只被with和catch语句影响。标识符解析步骤：</p>\n<ol>\n<li>获取作用域链的下一个对象，如果获取不到，则进入5；</li>\n<li>调用Result(1)对象的[[HasProperty]]方法，并传递此标识符作为property；</li>\n<li>若Result(2)为true，则返回一个引用类型的值，它的base object是Result(1)对象，属性名是此标识符；</li>\n<li>否则，返回1继续；</li>\n<li>返回一个引用类型的值，它的base object为null，属性名是此标识符。</li>\n</ol>\n<h3 id=\"Global-Object\"><a href=\"#Global-Object\" class=\"headerlink\" title=\"Global Object\"></a>Global Object</h3><p>有一个唯一的global object，在未进入任何execution context之前就创建了。它有以下属性：</p>\n<ul>\n<li>内建对象如：Math/String/Data/parseInt等，它们有DontEnum的attributes；</li>\n<li>额外的宿主定义的属性。可能包含一个属性，其值为全局对象自身。例如，在HTML文档对象模型中，全局对象的window属性就是全局对象自身；</li>\n</ul>\n<p>当进入到execution contexts中时，额外的属性可能会被追加到全局对象上，初始的属性也可能会改变。</p>\n<h3 id=\"Activation-Object\"><a href=\"#Activation-Object\" class=\"headerlink\" title=\"Activation Object\"></a>Activation Object</h3><p>当进入到function code的execution context中时，一个称为Activation object(简称AO)就被创建了，并被关联到该execution contect上。这个AO有一个名为arguments的Property，且其有DontDelete的attribute。这个property的初始值是一个arguments object。<br>这个AO接下来用来充作variable instantiation中的VO。<br>AO只是一种机制，不可能通过javascript代码访问到这个对象(虽然可以访问到这个对象的成员)。当一个call操作被应用到一个base object为一个AO的引用类型的值的时候，这个call的this就被设置为null。</p>\n<h3 id=\"This\"><a href=\"#This\" class=\"headerlink\" title=\"This\"></a>This</h3><p>当进入execution context时，该execution context会关联一个this值。并且在这个execution context中this值是不可变的。</p>\n<h3 id=\"Arguments-Object\"><a href=\"#Arguments-Object\" class=\"headerlink\" title=\"Arguments Object\"></a>Arguments Object</h3><p>当进入一个function code的execution context时，一个arguments object被创建并初始化：</p>\n<ul>\n<li>Arguments Object的内部属性[[Prototype]]被设置为Object.prototype；</li>\n<li>一个名为callee的DontEnum属性被创建，它的初始值为当前执行的函数对象。有了这个属性，就可以实现匿名函数的递归了;</li>\n<li>一个名为length的DontEnum属性被创建，它的初始值为caller传递的实参个数；</li>\n<li>一个名为ToString(arg)的DontEnum属性被创建，它的初始值为caller传递的实参(arg=0表示第一个实参，访问方式为arguments[0])，这个属性与AO/VO中实参属性共享其值，它们能相互影响。</li>\n</ul>\n<h2 id=\"Entering-An-Execution-Context\"><a href=\"#Entering-An-Execution-Context\" class=\"headerlink\" title=\"Entering An Execution Context\"></a>Entering An Execution Context</h2><p>每个函数和构造子调用都将进入一个新的execution context中，即使是一个递归的函数调用。每一个return都将退出一个execution context。一个没有捕获的异常抛出，可能会退出一个或多个execution context。<br>当进入一个execution context时，scope chain就被创建并被初始化了，variable instanitiation也就完成了，并且this值也确定了。它们的初始化过程取决于执行的executable code类型。</p>\n<h3 id=\"Global-Code\"><a href=\"#Global-Code\" class=\"headerlink\" title=\"Global Code\"></a>Global Code</h3><ul>\n<li>作用域链被创建，并初始化为只包含global object；</li>\n<li>Variable instantiation被执行：使用global object作为VO，并设置为DontDelete；</li>\n<li>this值被设置为global object；</li>\n</ul>\n<h3 id=\"Eval-Code\"><a href=\"#Eval-Code\" class=\"headerlink\" title=\"Eval Code\"></a>Eval Code</h3><p>当进入eval code的execution context时，先前的活跃active execution context(也被称为calling context)用来决定scope chain，variable object和this值。如果不存在calling context，那么初始化scope chain，variable object和this值的过程与global code一样，否则：</p>\n<ul>\n<li>作用域链按同样的顺序包含calling context的作用域链中的所有对象，这包括在calling context中通过with/catch语句追加到作用域链中的对象；</li>\n<li>使用calling context的VO对象来执行Variable instantiation过程，但清空property attributes；</li>\n<li>this值设置为calling context的this值；</li>\n</ul>\n<h3 id=\"Function-Code\"><a href=\"#Function-Code\" class=\"headerlink\" title=\"Function Code\"></a>Function Code</h3><ul>\n<li>scope chain初始化为包含AO，紧跟着的是当前Function object的[[Scope]]属性中保存的scope chain中的所有对象；</li>\n<li>Variable instantiation执行：使用AO作为VO，并设置DontDelete；</li>\n<li>当caller的this值是对象时，则设置当前的this值为call的this值。否则设置当前的this值为global object；</li>\n</ul>\n<h2 id=\"Expressions\"><a href=\"#Expressions\" class=\"headerlink\" title=\"Expressions\"></a>Expressions</h2><h2 id=\"Statements\"><a href=\"#Statements\" class=\"headerlink\" title=\"Statements\"></a>Statements</h2><h2 id=\"Function-Definition\"><a href=\"#Function-Definition\" class=\"headerlink\" title=\"Function Definition\"></a>Function Definition</h2><h2 id=\"Native-Javascript-Objects\"><a href=\"#Native-Javascript-Objects\" class=\"headerlink\" title=\"Native Javascript Objects\"></a>Native Javascript Objects</h2><p>在javascript程序执行前就已经存在一些内建对象了。其中一个就是global object，它存在于scope chain中。其它的作为global object的初始properties访问。<br>如果内建对象有[[Call]]这一内部property，则它的[[Class]]属性值为”Function”，否则[[Class]]属性值为”Object”<br>许多的内建对象同时也是函数(即函数对象)：它们可以被调用。这些函数对象中的某些还是constructors：可以用于new操作符。对于每个内建函数对象，规范描述了该函数调用时的形参及该对象的properties。对于每个内建constructor，规范还描述了其原型对象的properties及通过该构造子实例化出来的子对象的properties。<br>如果一个函数或构造子调用时实参个数少于形参，那么剩下的形参被赋值为undefined。<br>如果一个函数或构造子调用时实参个数多于形参，那么它的行为是未定义的。这种情况下，允许实现抛出一个TypeError的异常。<br>每个内建函数对象(包括构造对象)都有Function的原型对象，即Function.prototype作为它们的[[Prototype]]属性值，eg：Function.__proto__==Function.prototype。<br>每个内建原型对象都有Object的原型对象，即Object.prototype作为他们的[[Prototype]]属性值。eg：Function.prototype.__proto__ == Object.prototype。<br>总结：函数对象的原型对象是Function.prototype；其他对象的原型对象是Object.prototype；而Object.prototype的原型对象为null(即Object.prototype.__proto__==null)。<br>所有的内建非构造子函数对象都不会实现内部属性[[Construct]]方法及prototype属性。所有的内建函数对象都一个表示形参个数的{ReadOnly/DontDelete/DontEnum}的length属性。</p>\n<h3 id=\"The-Global-Object\"><a href=\"#The-Global-Object\" class=\"headerlink\" title=\"The Global Object\"></a>The Global Object</h3><p>全局对象并没有[[Construct]]属性(否则就是构造子了)，所以不能对全局对象进行new操作。全局对象也没有[[Call]]属性(否则就是函数对象了)，所以全局对象不能作为函数来调用。<br>全局对象的[[Prototype]]及[[Class]]属性值是依赖于实现的。</p>\n<h4 id=\"Value-Properties-of-the-Global-Object\"><a href=\"#Value-Properties-of-the-Global-Object\" class=\"headerlink\" title=\"Value Properties of the Global Object\"></a>Value Properties of the Global Object</h4><ul>\n<li>NaN，初始值为NaN，{DontEnum, DontDelete}</li>\n<li>Infinity，初始值为+o，{DontEnum，DontDelete}</li>\n<li>undefined，初始值是undefined，{DontEnum，DontDelete}</li>\n</ul>\n<h4 id=\"Function-Properties-of-the-Global-Object\"><a href=\"#Function-Properties-of-the-Global-Object\" class=\"headerlink\" title=\"Function Properties of the Global Object\"></a>Function Properties of the Global Object</h4><ul>\n<li>eval(x)</li>\n<li>parseInt(string, radix)</li>\n<li>parseFloat(string)</li>\n<li>isNaN(number)</li>\n<li>isFinite(number)</li>\n</ul>\n<h4 id=\"URI-Handling-Function-Properties\"><a href=\"#URI-Handling-Function-Properties\" class=\"headerlink\" title=\"URI Handling Function Properties\"></a>URI Handling Function Properties</h4><ul>\n<li>decodeURI(encodedURI)</li>\n<li>decodeURIComponent(encodedURIComponent)</li>\n<li>encodeURI(uri)</li>\n<li>encodeURIComponent(uriComponent)</li>\n</ul>\n<h4 id=\"Constructor-Properties-of-the-Global-Object\"><a href=\"#Constructor-Properties-of-the-Global-Object\" class=\"headerlink\" title=\"Constructor Properties of the Global Object\"></a>Constructor Properties of the Global Object</h4><ul>\n<li>Object</li>\n<li>Function</li>\n<li>Array</li>\n<li>String</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n<li>EvalError</li>\n<li>RangeError</li>\n<li>ReferenceError</li>\n<li>SyntaxError</li>\n<li>TypeError</li>\n<li>URIError</li>\n</ul>"},{"title":"[译] 解析JavaScript的事件循环机制","date":"2014-03-13T09:39:17.000Z","_content":"[原文链接](http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/)\n\n## 目的\n在web浏览器的世界中，JavaScript可以说是无处不在，也正因如此，大部分人对\nJavaScript的事件驱动(event-driven)模型，以及它与Ruby，Python，\nJava等语言所使用的请求-响应(request-response)模型的区别或多或少都有一些\n基本的了解。我将在本文中阐述JavaScript并发(concurrency)模型的一些核心\n概念，包括事件循环(event-loop)和消息队列(message queue)，以便帮你有更\n深入的理解。<!--more-->\n\n\n## 本文受众\n本文主要面对的是在客户端或服务端使用JavaScript的web开发者。如果你已经非常\n熟悉事件循环机制了，敬请拍砖。如果不是，我希望你能从本文有所收获。\n\n\n## 非阻塞I/O\n在JavaScript中，几乎所有的I/O都是非阻塞(non-blocking)的。包括HTTP请求，\n数据库操作，以及磁盘的读写。当执行这些I/O指令时，唯一的js执行线程会\n请求runtime去做这些I/O，并提供一个callback函数，然后执行线程继续\n压入执行后续的其它指令。当这个I/O操作被执行完后，runtime就会压入一条\n包含对应callback的消息到执行线程的消息队列中。在后续的某个时刻，这条消息\n被执行线程取出来并执行其中的callback函数。\n\n这种模型对于用户界面的开发者而言再熟悉不过了。诸如`鼠标按下`,\n`点击`等事件可以在任意时刻被触发。这与在服务端应用中典型的同步，\n请求-相应模型有很大的区别。\n\n我们来看一下这两种类型的区别。考虑HTTP请求www.google.com并输\n出响应到控制台。首先上Ruby代码:\n\n```ruby\nresponse = Faraday.get 'http://www.google.com'\nputs response\nputs 'Done!'\n```\n执行步骤很简明：\n\n1. 执行get方法，执行线程等待响应\n2. get方法接受到Google的响应，并返回给调用者，保存到response变量中\n3. 输出response变量到控制台\n4. 输出`Done!`到控制台\n\n而用JavaScript(Node.js)来实现:\n```javascript\nrequest('http://www.google.com', function(error, response, body) {\n    console.log(body); });\nconsole.log('Done!');\n```\n\n有点不一样吧，并且结果有很大区别：\n\n1. 执行request函数，传递一个匿名函数作为回调\n2. 立刻输出'Done!'到控制台\n3. 后续某个时间获得Google的响应数据后，执行先前传递的回调(输出response到控制台)\n\n\n## 事件循环\n将调用与(I/O)响应的解耦允许JavaScript执行线程去执行其它的指令，而不用等待\nI/O操作的完成及回调的执行。但这些callback被存放在内存的什么位置呢？它们以什么样\n的顺序执行的呢？什么导致callback被执行的呢？\n\nJavaScript的执行线程包含一个消息队列，用来存储将被处理的消息及其关联的callback\n函数。每当产生一个事件(例如鼠标点击，收到HTTP响应)，并伴随着一个回调函数，都会生成\n一个消息，并被压入队列。但如果产生事件时没有相应的回调函数提供，那么就不有消息压入队\n列。(整个程序作为初始消息回调压入队列)\n\n每次事件循环中(每循环一次，称为一个tick)，都会从消息队列中取一条消息，当取到一条\n消息时，相应的回调函数就会被执行。\n\n```javascript\nfunction init() {\n    var link = document.getElementById(\"foo\");\n    link.addEventListener(\"click\", function changeColor() {\n        this.style.color = \"burlywook\";\n    });\n}\n```\n\n{% img myimg https://erinswensonhealey.mybalsamiq.com/mockups/1228688.png?key=3f4ddd52e36d26e53ce8028ea38b5b64592e6b1a %}\n\n(从图中1开始看)回调函数的调用作为call stack上的初始帧。由于JavaScript执行引擎\n是单线程的，后续的消息提取和处理就会被暂停，直到当前stack上所有的调用都返回为止。\n\n在这个例子当中，当用户点击`foo`标签时，`onclick`事件被触发了，这时，一个消息(包含它的回调函数changeColor)被压入到了消息队列中了。当这条消息被取出时，它的\n回调函数changeColor将会被执行。当changeColor返回时(或抛出了error)，该消息\n处理完毕，事件循环才能取下一条消息来处理。\n\n\n## 执行消息队列中的回调函数时产生新的消息\n如果一个异步函数(如setTimeout)被调用了，那么相应的回调函数最终会在后续某个事件\n循环中作为消息的回调函数而被执行。看下面这个例子：\n```javascript\nfunction f(){\n\tconsole.log(\"foo\");\n\tsetTimeout(g, 0);\n\tconsole.log(\"baz\");\n\th();\n}\n\nfunction g() {\n\tconsole.log(\"bar\");\n}\n\nfunction h() {\n\tconsole.log(\"blix\");\n}\n\nf();\n```\n\n由于setTimeout函数的非阻塞特性，它的回调函数至少在未来0微秒后执行，并且在本次\n事件循环处理消息过程中不执行。在这个例子中，调用了setTimeout，并传递回调函数g\n以及0微秒的超时时间。当指定的超时时间满足以后(本例中几乎瞬时)，一个包含回调函数g\n的消息将会被压人消息队列。最终控制台将会依次显示：`foo`，`baz`，`blix`。最后在\n下一次事件循环处理消息(tick)的时候，打印出`bar`来。如果在同一个调用帧中有两次调\n用setTimeout，且超时时间相同，那么这两个包含相应回调函数的异步消息将以调用的顺序\n进入消息队列中。\n\n异步函数(如setTimeout)很容易实现任务的延迟执行，而不需要spawn出新的线程。JavaScript\n的异步函数通常只有两类：I/O和timing。\n\n\n## Web Workers\n通过使用Web Workers技术可以把一些费时的操作放到worker线程中去执行，从而分解主线\n程的执行压力。worker线程包含一个独立的消息队列，事件循环以及内存空间。worker线程\n与主线程之间是通过消息传递的方式进行通信的。\n\n{% img myimg https://erinswensonhealey.mybalsamiq.com/mockups/1218698.png?key=3f4ddd52e36d26e53ce8028ea38b5b64592e6b1a %}\n\n首先看一下worker线程的代码：\n```javascript\n// our worker, which does some CPU-intensive operation\nvar reportResult = function(e) {\n\tpi = SomeLib.computePiToSpecifiedDecimals(e.data);\n\tpostMessage(pi);\n}\n\nonmessage = reportResult;\n```\n\n接着看一下主线程的调用：\n```javascript\n// our main code, in a `<script>` tag in our HTML page;\nvar piWorker = new Worker(\"pi_calculator.js\");\nvar logResult = function(e) {\n\tconsole.log(\"PI: \" + e.data);\n};\n\npiWorker.addEventListener(\"message\", logResult, false);\npiWorker.postMessage(100000);\n```\n在这个例子中，主线程spawn出一个worker线程，并且为其注册logResult\n回调函数到`message`事件上。当worker线程接收到来自主线程的消息时，\nworker线程将消息及回调函数logResult绑定在一起压入自身的消息队列中。\n当worker消息从其消息队列取消息时，会向主线程回馈一个消息，同样绑定\n回调函数logResult。通过这种方式，开发者就可以将CPU密集型的任务代理给\nworker线程来执行，而不用阻塞主线程，从而主线程就能继续处理消息和事件了。\n\n\n## 总结\nJavaScript的事件驱动模型与许多程序员所熟悉的请求-响应模型是有很大区别\n的，但一点也不高深莫测。只用简单的消息队列以及事件循环，JavaScript开发\n者就可以使用大量的异步回调来构建它们的系统，让runtime在等待外部事件的发\n生的时候，处理并发指令。但这并不是唯一一种处理并发的方式，在本系列的下一\n篇文章中，我将比较一下JavaScript的并发模型与Ruby的MRI技术(通过多线程\n和GIL)，Ruby的EventMachine技术及Java的多线程技术的并发模型。\n\n\n## 相关阅读\n* [The JavaScript Event Loop: Concurrency in the Language of the Web](https://docs.google.com/presentation/d/1KtgaIvDQwMaqZ6ax3zU2oka62sF2ZQSPv1SEirD-XtY/edit?usp=sharing)\n* [Concurrency model and Event Loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop) @ MDN\n* [An intro to the Node.js platform](http://www.aaronstannard.com/post/2011/12/14/Intro-to-NodeJS-for-NET-Developers.aspx), by Aaron Stannard","source":"_posts/2014-03-13-the-javascript-event-loop-explained.md","raw":"---\ntitle: \"[译] 解析JavaScript的事件循环机制\"\ndate: 2014-03-13 17:39:17 +0800\ncategories: javascript\n---\n[原文链接](http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/)\n\n## 目的\n在web浏览器的世界中，JavaScript可以说是无处不在，也正因如此，大部分人对\nJavaScript的事件驱动(event-driven)模型，以及它与Ruby，Python，\nJava等语言所使用的请求-响应(request-response)模型的区别或多或少都有一些\n基本的了解。我将在本文中阐述JavaScript并发(concurrency)模型的一些核心\n概念，包括事件循环(event-loop)和消息队列(message queue)，以便帮你有更\n深入的理解。<!--more-->\n\n\n## 本文受众\n本文主要面对的是在客户端或服务端使用JavaScript的web开发者。如果你已经非常\n熟悉事件循环机制了，敬请拍砖。如果不是，我希望你能从本文有所收获。\n\n\n## 非阻塞I/O\n在JavaScript中，几乎所有的I/O都是非阻塞(non-blocking)的。包括HTTP请求，\n数据库操作，以及磁盘的读写。当执行这些I/O指令时，唯一的js执行线程会\n请求runtime去做这些I/O，并提供一个callback函数，然后执行线程继续\n压入执行后续的其它指令。当这个I/O操作被执行完后，runtime就会压入一条\n包含对应callback的消息到执行线程的消息队列中。在后续的某个时刻，这条消息\n被执行线程取出来并执行其中的callback函数。\n\n这种模型对于用户界面的开发者而言再熟悉不过了。诸如`鼠标按下`,\n`点击`等事件可以在任意时刻被触发。这与在服务端应用中典型的同步，\n请求-相应模型有很大的区别。\n\n我们来看一下这两种类型的区别。考虑HTTP请求www.google.com并输\n出响应到控制台。首先上Ruby代码:\n\n```ruby\nresponse = Faraday.get 'http://www.google.com'\nputs response\nputs 'Done!'\n```\n执行步骤很简明：\n\n1. 执行get方法，执行线程等待响应\n2. get方法接受到Google的响应，并返回给调用者，保存到response变量中\n3. 输出response变量到控制台\n4. 输出`Done!`到控制台\n\n而用JavaScript(Node.js)来实现:\n```javascript\nrequest('http://www.google.com', function(error, response, body) {\n    console.log(body); });\nconsole.log('Done!');\n```\n\n有点不一样吧，并且结果有很大区别：\n\n1. 执行request函数，传递一个匿名函数作为回调\n2. 立刻输出'Done!'到控制台\n3. 后续某个时间获得Google的响应数据后，执行先前传递的回调(输出response到控制台)\n\n\n## 事件循环\n将调用与(I/O)响应的解耦允许JavaScript执行线程去执行其它的指令，而不用等待\nI/O操作的完成及回调的执行。但这些callback被存放在内存的什么位置呢？它们以什么样\n的顺序执行的呢？什么导致callback被执行的呢？\n\nJavaScript的执行线程包含一个消息队列，用来存储将被处理的消息及其关联的callback\n函数。每当产生一个事件(例如鼠标点击，收到HTTP响应)，并伴随着一个回调函数，都会生成\n一个消息，并被压入队列。但如果产生事件时没有相应的回调函数提供，那么就不有消息压入队\n列。(整个程序作为初始消息回调压入队列)\n\n每次事件循环中(每循环一次，称为一个tick)，都会从消息队列中取一条消息，当取到一条\n消息时，相应的回调函数就会被执行。\n\n```javascript\nfunction init() {\n    var link = document.getElementById(\"foo\");\n    link.addEventListener(\"click\", function changeColor() {\n        this.style.color = \"burlywook\";\n    });\n}\n```\n\n{% img myimg https://erinswensonhealey.mybalsamiq.com/mockups/1228688.png?key=3f4ddd52e36d26e53ce8028ea38b5b64592e6b1a %}\n\n(从图中1开始看)回调函数的调用作为call stack上的初始帧。由于JavaScript执行引擎\n是单线程的，后续的消息提取和处理就会被暂停，直到当前stack上所有的调用都返回为止。\n\n在这个例子当中，当用户点击`foo`标签时，`onclick`事件被触发了，这时，一个消息(包含它的回调函数changeColor)被压入到了消息队列中了。当这条消息被取出时，它的\n回调函数changeColor将会被执行。当changeColor返回时(或抛出了error)，该消息\n处理完毕，事件循环才能取下一条消息来处理。\n\n\n## 执行消息队列中的回调函数时产生新的消息\n如果一个异步函数(如setTimeout)被调用了，那么相应的回调函数最终会在后续某个事件\n循环中作为消息的回调函数而被执行。看下面这个例子：\n```javascript\nfunction f(){\n\tconsole.log(\"foo\");\n\tsetTimeout(g, 0);\n\tconsole.log(\"baz\");\n\th();\n}\n\nfunction g() {\n\tconsole.log(\"bar\");\n}\n\nfunction h() {\n\tconsole.log(\"blix\");\n}\n\nf();\n```\n\n由于setTimeout函数的非阻塞特性，它的回调函数至少在未来0微秒后执行，并且在本次\n事件循环处理消息过程中不执行。在这个例子中，调用了setTimeout，并传递回调函数g\n以及0微秒的超时时间。当指定的超时时间满足以后(本例中几乎瞬时)，一个包含回调函数g\n的消息将会被压人消息队列。最终控制台将会依次显示：`foo`，`baz`，`blix`。最后在\n下一次事件循环处理消息(tick)的时候，打印出`bar`来。如果在同一个调用帧中有两次调\n用setTimeout，且超时时间相同，那么这两个包含相应回调函数的异步消息将以调用的顺序\n进入消息队列中。\n\n异步函数(如setTimeout)很容易实现任务的延迟执行，而不需要spawn出新的线程。JavaScript\n的异步函数通常只有两类：I/O和timing。\n\n\n## Web Workers\n通过使用Web Workers技术可以把一些费时的操作放到worker线程中去执行，从而分解主线\n程的执行压力。worker线程包含一个独立的消息队列，事件循环以及内存空间。worker线程\n与主线程之间是通过消息传递的方式进行通信的。\n\n{% img myimg https://erinswensonhealey.mybalsamiq.com/mockups/1218698.png?key=3f4ddd52e36d26e53ce8028ea38b5b64592e6b1a %}\n\n首先看一下worker线程的代码：\n```javascript\n// our worker, which does some CPU-intensive operation\nvar reportResult = function(e) {\n\tpi = SomeLib.computePiToSpecifiedDecimals(e.data);\n\tpostMessage(pi);\n}\n\nonmessage = reportResult;\n```\n\n接着看一下主线程的调用：\n```javascript\n// our main code, in a `<script>` tag in our HTML page;\nvar piWorker = new Worker(\"pi_calculator.js\");\nvar logResult = function(e) {\n\tconsole.log(\"PI: \" + e.data);\n};\n\npiWorker.addEventListener(\"message\", logResult, false);\npiWorker.postMessage(100000);\n```\n在这个例子中，主线程spawn出一个worker线程，并且为其注册logResult\n回调函数到`message`事件上。当worker线程接收到来自主线程的消息时，\nworker线程将消息及回调函数logResult绑定在一起压入自身的消息队列中。\n当worker消息从其消息队列取消息时，会向主线程回馈一个消息，同样绑定\n回调函数logResult。通过这种方式，开发者就可以将CPU密集型的任务代理给\nworker线程来执行，而不用阻塞主线程，从而主线程就能继续处理消息和事件了。\n\n\n## 总结\nJavaScript的事件驱动模型与许多程序员所熟悉的请求-响应模型是有很大区别\n的，但一点也不高深莫测。只用简单的消息队列以及事件循环，JavaScript开发\n者就可以使用大量的异步回调来构建它们的系统，让runtime在等待外部事件的发\n生的时候，处理并发指令。但这并不是唯一一种处理并发的方式，在本系列的下一\n篇文章中，我将比较一下JavaScript的并发模型与Ruby的MRI技术(通过多线程\n和GIL)，Ruby的EventMachine技术及Java的多线程技术的并发模型。\n\n\n## 相关阅读\n* [The JavaScript Event Loop: Concurrency in the Language of the Web](https://docs.google.com/presentation/d/1KtgaIvDQwMaqZ6ax3zU2oka62sF2ZQSPv1SEirD-XtY/edit?usp=sharing)\n* [Concurrency model and Event Loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop) @ MDN\n* [An intro to the Node.js platform](http://www.aaronstannard.com/post/2011/12/14/Intro-to-NodeJS-for-NET-Developers.aspx), by Aaron Stannard","slug":"the-javascript-event-loop-explained","published":1,"updated":"2017-12-26T11:21:51.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbnjnr9j0002v4tntu1xapvo","content":"<p><a href=\"http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>在web浏览器的世界中，JavaScript可以说是无处不在，也正因如此，大部分人对<br>JavaScript的事件驱动(event-driven)模型，以及它与Ruby，Python，<br>Java等语言所使用的请求-响应(request-response)模型的区别或多或少都有一些<br>基本的了解。我将在本文中阐述JavaScript并发(concurrency)模型的一些核心<br>概念，包括事件循环(event-loop)和消息队列(message queue)，以便帮你有更<br>深入的理解。<a id=\"more\"></a></p>\n<h2 id=\"本文受众\"><a href=\"#本文受众\" class=\"headerlink\" title=\"本文受众\"></a>本文受众</h2><p>本文主要面对的是在客户端或服务端使用JavaScript的web开发者。如果你已经非常<br>熟悉事件循环机制了，敬请拍砖。如果不是，我希望你能从本文有所收获。</p>\n<h2 id=\"非阻塞I-O\"><a href=\"#非阻塞I-O\" class=\"headerlink\" title=\"非阻塞I/O\"></a>非阻塞I/O</h2><p>在JavaScript中，几乎所有的I/O都是非阻塞(non-blocking)的。包括HTTP请求，<br>数据库操作，以及磁盘的读写。当执行这些I/O指令时，唯一的js执行线程会<br>请求runtime去做这些I/O，并提供一个callback函数，然后执行线程继续<br>压入执行后续的其它指令。当这个I/O操作被执行完后，runtime就会压入一条<br>包含对应callback的消息到执行线程的消息队列中。在后续的某个时刻，这条消息<br>被执行线程取出来并执行其中的callback函数。</p>\n<p>这种模型对于用户界面的开发者而言再熟悉不过了。诸如<code>鼠标按下</code>,<br><code>点击</code>等事件可以在任意时刻被触发。这与在服务端应用中典型的同步，<br>请求-相应模型有很大的区别。</p>\n<p>我们来看一下这两种类型的区别。考虑HTTP请求www.google.com并输<br>出响应到控制台。首先上Ruby代码:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response = Faraday.get <span class=\"string\">'http://www.google.com'</span></span><br><span class=\"line\">puts response</span><br><span class=\"line\">puts <span class=\"string\">'Done!'</span></span><br></pre></td></tr></table></figure>\n<p>执行步骤很简明：</p>\n<ol>\n<li>执行get方法，执行线程等待响应</li>\n<li>get方法接受到Google的响应，并返回给调用者，保存到response变量中</li>\n<li>输出response变量到控制台</li>\n<li>输出<code>Done!</code>到控制台</li>\n</ol>\n<p>而用JavaScript(Node.js)来实现:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request(<span class=\"string\">'http://www.google.com'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, response, body</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(body); &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Done!'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>有点不一样吧，并且结果有很大区别：</p>\n<ol>\n<li>执行request函数，传递一个匿名函数作为回调</li>\n<li>立刻输出’Done!’到控制台</li>\n<li>后续某个时间获得Google的响应数据后，执行先前传递的回调(输出response到控制台)</li>\n</ol>\n<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><p>将调用与(I/O)响应的解耦允许JavaScript执行线程去执行其它的指令，而不用等待<br>I/O操作的完成及回调的执行。但这些callback被存放在内存的什么位置呢？它们以什么样<br>的顺序执行的呢？什么导致callback被执行的呢？</p>\n<p>JavaScript的执行线程包含一个消息队列，用来存储将被处理的消息及其关联的callback<br>函数。每当产生一个事件(例如鼠标点击，收到HTTP响应)，并伴随着一个回调函数，都会生成<br>一个消息，并被压入队列。但如果产生事件时没有相应的回调函数提供，那么就不有消息压入队<br>列。(整个程序作为初始消息回调压入队列)</p>\n<p>每次事件循环中(每循环一次，称为一个tick)，都会从消息队列中取一条消息，当取到一条<br>消息时，相应的回调函数就会被执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> link = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\">    link.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColor</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.style.color = <span class=\"string\">\"burlywook\"</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"https://erinswensonhealey.mybalsamiq.com/mockups/1228688.png?key=3f4ddd52e36d26e53ce8028ea38b5b64592e6b1a\" class=\"myimg\">\n<p>(从图中1开始看)回调函数的调用作为call stack上的初始帧。由于JavaScript执行引擎<br>是单线程的，后续的消息提取和处理就会被暂停，直到当前stack上所有的调用都返回为止。</p>\n<p>在这个例子当中，当用户点击<code>foo</code>标签时，<code>onclick</code>事件被触发了，这时，一个消息(包含它的回调函数changeColor)被压入到了消息队列中了。当这条消息被取出时，它的<br>回调函数changeColor将会被执行。当changeColor返回时(或抛出了error)，该消息<br>处理完毕，事件循环才能取下一条消息来处理。</p>\n<h2 id=\"执行消息队列中的回调函数时产生新的消息\"><a href=\"#执行消息队列中的回调函数时产生新的消息\" class=\"headerlink\" title=\"执行消息队列中的回调函数时产生新的消息\"></a>执行消息队列中的回调函数时产生新的消息</h2><p>如果一个异步函数(如setTimeout)被调用了，那么相应的回调函数最终会在后续某个事件<br>循环中作为消息的回调函数而被执行。看下面这个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\">\tsetTimeout(g, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"baz\"</span>);</span><br><span class=\"line\">\th();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"bar\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">h</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"blix\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure></p>\n<p>由于setTimeout函数的非阻塞特性，它的回调函数至少在未来0微秒后执行，并且在本次<br>事件循环处理消息过程中不执行。在这个例子中，调用了setTimeout，并传递回调函数g<br>以及0微秒的超时时间。当指定的超时时间满足以后(本例中几乎瞬时)，一个包含回调函数g<br>的消息将会被压人消息队列。最终控制台将会依次显示：<code>foo</code>，<code>baz</code>，<code>blix</code>。最后在<br>下一次事件循环处理消息(tick)的时候，打印出<code>bar</code>来。如果在同一个调用帧中有两次调<br>用setTimeout，且超时时间相同，那么这两个包含相应回调函数的异步消息将以调用的顺序<br>进入消息队列中。</p>\n<p>异步函数(如setTimeout)很容易实现任务的延迟执行，而不需要spawn出新的线程。JavaScript<br>的异步函数通常只有两类：I/O和timing。</p>\n<h2 id=\"Web-Workers\"><a href=\"#Web-Workers\" class=\"headerlink\" title=\"Web Workers\"></a>Web Workers</h2><p>通过使用Web Workers技术可以把一些费时的操作放到worker线程中去执行，从而分解主线<br>程的执行压力。worker线程包含一个独立的消息队列，事件循环以及内存空间。worker线程<br>与主线程之间是通过消息传递的方式进行通信的。</p>\n<img src=\"https://erinswensonhealey.mybalsamiq.com/mockups/1218698.png?key=3f4ddd52e36d26e53ce8028ea38b5b64592e6b1a\" class=\"myimg\">\n<p>首先看一下worker线程的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// our worker, which does some CPU-intensive operation</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reportResult = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\tpi = SomeLib.computePiToSpecifiedDecimals(e.data);</span><br><span class=\"line\">\tpostMessage(pi);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onmessage = reportResult;</span><br></pre></td></tr></table></figure></p>\n<p>接着看一下主线程的调用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// our main code, in a `&lt;script&gt;` tag in our HTML page;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> piWorker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">\"pi_calculator.js\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> logResult = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"PI: \"</span> + e.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">piWorker.addEventListener(<span class=\"string\">\"message\"</span>, logResult, <span class=\"literal\">false</span>);</span><br><span class=\"line\">piWorker.postMessage(<span class=\"number\">100000</span>);</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，主线程spawn出一个worker线程，并且为其注册logResult<br>回调函数到<code>message</code>事件上。当worker线程接收到来自主线程的消息时，<br>worker线程将消息及回调函数logResult绑定在一起压入自身的消息队列中。<br>当worker消息从其消息队列取消息时，会向主线程回馈一个消息，同样绑定<br>回调函数logResult。通过这种方式，开发者就可以将CPU密集型的任务代理给<br>worker线程来执行，而不用阻塞主线程，从而主线程就能继续处理消息和事件了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>JavaScript的事件驱动模型与许多程序员所熟悉的请求-响应模型是有很大区别<br>的，但一点也不高深莫测。只用简单的消息队列以及事件循环，JavaScript开发<br>者就可以使用大量的异步回调来构建它们的系统，让runtime在等待外部事件的发<br>生的时候，处理并发指令。但这并不是唯一一种处理并发的方式，在本系列的下一<br>篇文章中，我将比较一下JavaScript的并发模型与Ruby的MRI技术(通过多线程<br>和GIL)，Ruby的EventMachine技术及Java的多线程技术的并发模型。</p>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><ul>\n<li><a href=\"https://docs.google.com/presentation/d/1KtgaIvDQwMaqZ6ax3zU2oka62sF2ZQSPv1SEirD-XtY/edit?usp=sharing\" target=\"_blank\" rel=\"noopener\">The JavaScript Event Loop: Concurrency in the Language of the Web</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop\" target=\"_blank\" rel=\"noopener\">Concurrency model and Event Loop</a> @ MDN</li>\n<li><a href=\"http://www.aaronstannard.com/post/2011/12/14/Intro-to-NodeJS-for-NET-Developers.aspx\" target=\"_blank\" rel=\"noopener\">An intro to the Node.js platform</a>, by Aaron Stannard</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>在web浏览器的世界中，JavaScript可以说是无处不在，也正因如此，大部分人对<br>JavaScript的事件驱动(event-driven)模型，以及它与Ruby，Python，<br>Java等语言所使用的请求-响应(request-response)模型的区别或多或少都有一些<br>基本的了解。我将在本文中阐述JavaScript并发(concurrency)模型的一些核心<br>概念，包括事件循环(event-loop)和消息队列(message queue)，以便帮你有更<br>深入的理解。","more":"</p>\n<h2 id=\"本文受众\"><a href=\"#本文受众\" class=\"headerlink\" title=\"本文受众\"></a>本文受众</h2><p>本文主要面对的是在客户端或服务端使用JavaScript的web开发者。如果你已经非常<br>熟悉事件循环机制了，敬请拍砖。如果不是，我希望你能从本文有所收获。</p>\n<h2 id=\"非阻塞I-O\"><a href=\"#非阻塞I-O\" class=\"headerlink\" title=\"非阻塞I/O\"></a>非阻塞I/O</h2><p>在JavaScript中，几乎所有的I/O都是非阻塞(non-blocking)的。包括HTTP请求，<br>数据库操作，以及磁盘的读写。当执行这些I/O指令时，唯一的js执行线程会<br>请求runtime去做这些I/O，并提供一个callback函数，然后执行线程继续<br>压入执行后续的其它指令。当这个I/O操作被执行完后，runtime就会压入一条<br>包含对应callback的消息到执行线程的消息队列中。在后续的某个时刻，这条消息<br>被执行线程取出来并执行其中的callback函数。</p>\n<p>这种模型对于用户界面的开发者而言再熟悉不过了。诸如<code>鼠标按下</code>,<br><code>点击</code>等事件可以在任意时刻被触发。这与在服务端应用中典型的同步，<br>请求-相应模型有很大的区别。</p>\n<p>我们来看一下这两种类型的区别。考虑HTTP请求www.google.com并输<br>出响应到控制台。首先上Ruby代码:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response = Faraday.get <span class=\"string\">'http://www.google.com'</span></span><br><span class=\"line\">puts response</span><br><span class=\"line\">puts <span class=\"string\">'Done!'</span></span><br></pre></td></tr></table></figure>\n<p>执行步骤很简明：</p>\n<ol>\n<li>执行get方法，执行线程等待响应</li>\n<li>get方法接受到Google的响应，并返回给调用者，保存到response变量中</li>\n<li>输出response变量到控制台</li>\n<li>输出<code>Done!</code>到控制台</li>\n</ol>\n<p>而用JavaScript(Node.js)来实现:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request(<span class=\"string\">'http://www.google.com'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, response, body</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(body); &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Done!'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>有点不一样吧，并且结果有很大区别：</p>\n<ol>\n<li>执行request函数，传递一个匿名函数作为回调</li>\n<li>立刻输出’Done!’到控制台</li>\n<li>后续某个时间获得Google的响应数据后，执行先前传递的回调(输出response到控制台)</li>\n</ol>\n<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><p>将调用与(I/O)响应的解耦允许JavaScript执行线程去执行其它的指令，而不用等待<br>I/O操作的完成及回调的执行。但这些callback被存放在内存的什么位置呢？它们以什么样<br>的顺序执行的呢？什么导致callback被执行的呢？</p>\n<p>JavaScript的执行线程包含一个消息队列，用来存储将被处理的消息及其关联的callback<br>函数。每当产生一个事件(例如鼠标点击，收到HTTP响应)，并伴随着一个回调函数，都会生成<br>一个消息，并被压入队列。但如果产生事件时没有相应的回调函数提供，那么就不有消息压入队<br>列。(整个程序作为初始消息回调压入队列)</p>\n<p>每次事件循环中(每循环一次，称为一个tick)，都会从消息队列中取一条消息，当取到一条<br>消息时，相应的回调函数就会被执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> link = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\">    link.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColor</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.style.color = <span class=\"string\">\"burlywook\"</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"https://erinswensonhealey.mybalsamiq.com/mockups/1228688.png?key=3f4ddd52e36d26e53ce8028ea38b5b64592e6b1a\" class=\"myimg\">\n<p>(从图中1开始看)回调函数的调用作为call stack上的初始帧。由于JavaScript执行引擎<br>是单线程的，后续的消息提取和处理就会被暂停，直到当前stack上所有的调用都返回为止。</p>\n<p>在这个例子当中，当用户点击<code>foo</code>标签时，<code>onclick</code>事件被触发了，这时，一个消息(包含它的回调函数changeColor)被压入到了消息队列中了。当这条消息被取出时，它的<br>回调函数changeColor将会被执行。当changeColor返回时(或抛出了error)，该消息<br>处理完毕，事件循环才能取下一条消息来处理。</p>\n<h2 id=\"执行消息队列中的回调函数时产生新的消息\"><a href=\"#执行消息队列中的回调函数时产生新的消息\" class=\"headerlink\" title=\"执行消息队列中的回调函数时产生新的消息\"></a>执行消息队列中的回调函数时产生新的消息</h2><p>如果一个异步函数(如setTimeout)被调用了，那么相应的回调函数最终会在后续某个事件<br>循环中作为消息的回调函数而被执行。看下面这个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\">\tsetTimeout(g, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"baz\"</span>);</span><br><span class=\"line\">\th();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"bar\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">h</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"blix\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure></p>\n<p>由于setTimeout函数的非阻塞特性，它的回调函数至少在未来0微秒后执行，并且在本次<br>事件循环处理消息过程中不执行。在这个例子中，调用了setTimeout，并传递回调函数g<br>以及0微秒的超时时间。当指定的超时时间满足以后(本例中几乎瞬时)，一个包含回调函数g<br>的消息将会被压人消息队列。最终控制台将会依次显示：<code>foo</code>，<code>baz</code>，<code>blix</code>。最后在<br>下一次事件循环处理消息(tick)的时候，打印出<code>bar</code>来。如果在同一个调用帧中有两次调<br>用setTimeout，且超时时间相同，那么这两个包含相应回调函数的异步消息将以调用的顺序<br>进入消息队列中。</p>\n<p>异步函数(如setTimeout)很容易实现任务的延迟执行，而不需要spawn出新的线程。JavaScript<br>的异步函数通常只有两类：I/O和timing。</p>\n<h2 id=\"Web-Workers\"><a href=\"#Web-Workers\" class=\"headerlink\" title=\"Web Workers\"></a>Web Workers</h2><p>通过使用Web Workers技术可以把一些费时的操作放到worker线程中去执行，从而分解主线<br>程的执行压力。worker线程包含一个独立的消息队列，事件循环以及内存空间。worker线程<br>与主线程之间是通过消息传递的方式进行通信的。</p>\n<img src=\"https://erinswensonhealey.mybalsamiq.com/mockups/1218698.png?key=3f4ddd52e36d26e53ce8028ea38b5b64592e6b1a\" class=\"myimg\">\n<p>首先看一下worker线程的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// our worker, which does some CPU-intensive operation</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reportResult = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\tpi = SomeLib.computePiToSpecifiedDecimals(e.data);</span><br><span class=\"line\">\tpostMessage(pi);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onmessage = reportResult;</span><br></pre></td></tr></table></figure></p>\n<p>接着看一下主线程的调用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// our main code, in a `&lt;script&gt;` tag in our HTML page;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> piWorker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">\"pi_calculator.js\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> logResult = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"PI: \"</span> + e.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">piWorker.addEventListener(<span class=\"string\">\"message\"</span>, logResult, <span class=\"literal\">false</span>);</span><br><span class=\"line\">piWorker.postMessage(<span class=\"number\">100000</span>);</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，主线程spawn出一个worker线程，并且为其注册logResult<br>回调函数到<code>message</code>事件上。当worker线程接收到来自主线程的消息时，<br>worker线程将消息及回调函数logResult绑定在一起压入自身的消息队列中。<br>当worker消息从其消息队列取消息时，会向主线程回馈一个消息，同样绑定<br>回调函数logResult。通过这种方式，开发者就可以将CPU密集型的任务代理给<br>worker线程来执行，而不用阻塞主线程，从而主线程就能继续处理消息和事件了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>JavaScript的事件驱动模型与许多程序员所熟悉的请求-响应模型是有很大区别<br>的，但一点也不高深莫测。只用简单的消息队列以及事件循环，JavaScript开发<br>者就可以使用大量的异步回调来构建它们的系统，让runtime在等待外部事件的发<br>生的时候，处理并发指令。但这并不是唯一一种处理并发的方式，在本系列的下一<br>篇文章中，我将比较一下JavaScript的并发模型与Ruby的MRI技术(通过多线程<br>和GIL)，Ruby的EventMachine技术及Java的多线程技术的并发模型。</p>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><ul>\n<li><a href=\"https://docs.google.com/presentation/d/1KtgaIvDQwMaqZ6ax3zU2oka62sF2ZQSPv1SEirD-XtY/edit?usp=sharing\" target=\"_blank\" rel=\"noopener\">The JavaScript Event Loop: Concurrency in the Language of the Web</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop\" target=\"_blank\" rel=\"noopener\">Concurrency model and Event Loop</a> @ MDN</li>\n<li><a href=\"http://www.aaronstannard.com/post/2011/12/14/Intro-to-NodeJS-for-NET-Developers.aspx\" target=\"_blank\" rel=\"noopener\">An intro to the Node.js platform</a>, by Aaron Stannard</li>\n</ul>"},{"title":"[译] CouchDB 技术概述","date":"2014-06-23T08:32:14.000Z","_content":"[原文链接](http://docs.couchdb.org/en/latest/intro/overview.html)\n\n## Document 存储\n\n一个 CouchDB 服务器管理一些有名字的数据库，这些数据库里存储着称为\n`documents`的东西。每个 document 在数据库中被有一个唯一的名字，同\n时，CouchDB 提供了对其进行 reading 和 updating(add, edit, delete)\n操作的[RESTful](http://en.wikipedia.org/wiki/REST)\n[HTTP API](http://docs.couchdb.org/en/latest/api/basics.html#api-basics)。\n\nCouchDB 中数据的主要单元就是 document，它由任意数量的 field 和\nattachment 组成。document 还包含一个由数据库系统维护的自身元数据\n信息。document 的 field 是一些 name-value 对的集合，其中，name 是\n唯一的，value 可以为[各种类型](htp://docs.couchdb.org/en/latest/api/basics.html#json)(text, number, boolean, list等)，并且它们都是没\n有大小或数量限制的。\n\nCouchDB 的 document 更新模型是无锁的，乐观的。Document 的编辑流程\n通常是客户端应用先加载 documents，再应用一些变化，最后保存回数据库。\n如果在编辑的同时有另一个客户端先提交了保存，那么此时的修改会返回一\n个编辑冲突的错误。解决这种更新冲突的办法是，不指定 document 的最终\n版本，重新编辑提交一次。\n\nDocument 的更新操作（add, edit, delete）要么成功，要么失败。数据库\n是不会包含不完整的数据的。\n\n\n## ACID 特性\n\nCouchDB 文件布局和提交系统具备`Atomic Consistent Isolated Durable(ACID)`特性。在磁盘上，CouchDB绝不会覆盖已提交的数据或关联的结构，保证\n数据库文件状态总是一致性的。这是一种 `crash-only` 设计，当有进程挂掉时，CouchDB 不会做任何处理，只是简单的死去。\n\nDocument的更新（add, edit, delete）操作中，除了对`binary blobs` 数据\n是并发写的，其它都是顺序的。数据库读操作是立即执行的，不会加锁，也不会等待其他任何写操作或读操作完成的。即使对于同一个 document，多个客\n户端的读操作不会被加锁或者因并发更新而中断。CouchDB 的读操作使用了\n一种称为**[Multi-Version Concurrency Control](http://en.wikipedia.org/wiki/Multiversion_concurrency_control)**的模型，它保证每个客户端\n在读操作中，都可以获得数据库最新版本的一致性数据(see a consistent\nsnapshot of the database)。\n\nDocument 被索引在由它们的名字（DocID）和一个序列号构成的 B-trees 中\n。每一个更新都会产生一个新的序列号。序列号稍后被应用于数据库的增量\n变化中。当 document 被保存或删除时，这些 B-tree 索引都会被更新。索\n引的更新总是出现在索引文件的末尾（append-only更新）。\n\n在存储被适当包装的数据场景中，document 机制比在大多数数据库中把打\n包的数据切分成多个表和行来存储更有优势。当 document 数据被存储到磁盘时，document 的字段和元数据信息就被打包进缓冲中，同时，document 被\n顺序存放（方便后续高效地生成视图）。\n\n当 document 更新完成时，所有新的数据及关联的索引都会被刷入到磁盘，\n同时，事务提交总是保证数据库处于完全一致的状态中。提交出现在以下两步中：\n1. 所有的document数据及其索引的更新被同步刷入磁盘中。\n2. 数据库header的更新分成两步。先用一致的数据块填充文件的前4k空间，然后同步刷入磁盘中。\n\n如果在第1步中OS崩溃或发生断电了，被刷入的部分更新在重启时会被丢弃。\n如果这种情况发生在第2步当中（提交header），header的一份拷贝会被保留\n，来保证之前已提交数据的一致性。在发生崩溃或断电后，只会对header部分做一致性检查或修复。\n\n\n## Compaction\n\n浪费的空间会在精简过程中被释放。当数据库文件浪费的空间超过一定值时\n或者精简调度被触发，compaction 进程会复制数据库文件中的所有活跃数据\n到一个新的数据库文件中，然后丢弃旧的数据库文件。在整个期间，数据库\n的访问不会被中断。旧的数据库文件只会在当其所有的数据都被拷贝到新文件，并且用户的操作都过渡到新文件时才会被丢弃。\n\n\n## 视图\n\nACID 只能解决存储和更新的问题，但我们有时也需要按某种有用的方式来\n展示数据。CouchDB 不像 SQL 数据库那样必须小心地把数据切分到不同的表\n中，它会把数据存入半结构化的 documents中。CouchDB 的 document 是灵活的，并且它有一个隐式结构用来对付在表结构和数据的双向复制中\n的大多数难题和陷阱。\n\n但是，仅仅一个简单的 document 模型是很不够的。我们更多的是想要通过很多种不同的方式对我们的数据进行分析。对于这种没有按分类切分到不同的表中的数据，我们需要一种过滤，组织，报告的方式。\n\n### 视图模型\n\n为了解决给非结构化和半结构化的数据附加一种结构，CouchDB 集成了一种\n视图模型。视图是一种给 documents 做汇总和报告的方法。因为视图是动态\n构建的，并且不影响所依赖的 document，所以同一份数据可以有多种视图\n表示。\n视图的定义是完全虚拟的，并且只显示当前数据库实例的 documents，这就\n使视图与它所显示的数据本身隔离开来，并且也可以被复制。CouchDB 的视\n图被定义在一种特殊的`design documents`当中，并且也可以像普通的 documents那样被复制到不同的数据库实例当中。因此，在CouchDB中，不仅仅是数\n据可以被复制，整个应用的设计也可以被复制。\n\n### Javascript 视图函数\n\n视图的是通过在 map-reduce 系统中扮演map部分的 Javascript 函数来定义\n的。一个视图函数接受一个 CouchDB document作为参数，然后经过一些计算\n来决定这个数据是否是视图所需要的。可以给基于单 document 的视图添加\n多行，或者一行都不添加。\n\n### 视图索引\n\n视图是数据库真实 document 内容的一个动态表示，并且视图的创建也是非常容易的。为数据库中的大量 documents 生成一个视图是非常耗时的，所以系\n统不会每次都从头做起。\n\n为了提高视图的查询效率，视图引擎维护了一些视图的索引，并且增量更新\n它们以便反映数据库中的变化。CouchDB的核心设计是为效率的需要，大量\n优化视图及其索引的增量创建。\n\n视图及视图函数被定义在特殊“设计”的 documents，这样的一个 document\n包含了任意数量的视图函数。当一个用户使用一个视图时，视图的索引就会\n自动更新。一个 design document 中的所有视图作为一个组来索引。\n\n视图构建器使用序列号来决定视图组是否全部更新了。如果不是，视图引擎\n就会检查自上次刷新视图组后的全部 documents 变化（按数据打包序列顺\n序）。Documents 按照它们在磁盘文件出现的顺序开始读，减少磁头寻道频\n率。\n\n当视图被刷新时，仍然可以被同时读和查询。如果某个客户端从一个大视图\n中很慢地获取数据时，视图仍然可以被其他的客户端使用和刷新，且不会阻塞\n先前正在使用的客户端。视图索引刷新的同时，大量对视图的读和查询操作是不会有任何问题的。\n\n由于 documents 是被视图引擎调用用户定义的map/reduce函数来处理的，它\n们先前的行将从视图索引中移除。当视图函数操作一个 document 时， 函数\n返回结果将作为一个新的行被插入到视图中。\n\n视图索引的修改总是被写入到磁盘文件的末尾，来减少磁头寻道时间，以及保证在发生崩溃和断电时的写不会搞坏已有的索引。当崩溃发生在更新索引的过程中，未完成的索引修改将被简单的丢弃，并根据先前的提交状态重新构建索引增量。\n\n\n## 安全和校验\n\n对于需要读及更新 documents 的工程，CouchDB 提供了一个简单的读访问控\n制及更新校验的模型来被拓展以实现自定义的安全模型。\n\n### 管理员访问控制\n\nCouchDB 数据库提供了管理员账户。管理员账户可以创建其他的管理员账号，并且可以更新 design documents。Design documents是一种包含了视图定义\n及其他信息的特殊的 documents。\n\n### 更新校验\n\n由于 document 被写入到磁盘中，它们可以被javascript函数动态校验。当\ndocument 通过了所有的校验规则时，则更新操作被允许。如果校验失败，更\n新操作将被中止，同时用户客户端将返回一个错误响应。\n\n校验规则需要用户的认证信息及将被更新的 document 作为输入，我们可以\n通过验证用户的权限来实现自定义的 document 更新的安全模型。\n\nCouchDB 提供了一个基本的`author only`的 document 更新模型，它会校验\n用户是否在 document 的`author`字段中。更动态的校验模型也是可以的，\n比如检查一个单独的用户账户信息来判断权限。\n\n\n## 分布式更新及同步\n\nCouchDB 是一个基于对等的分布式数据库系统。它允许用户和服务器在未连接时也能访问和更新同一份数据。各自所做的修改可以在后续进行双向同步。\n\nCouchDB的 document 存储，视图，及安全模型被设计来共同实现真正高效的\n，可靠的双向同步。Documents 和 design documents都可以被同步，这就\n允许全部的数据库应用（包括应用设计，逻辑及数据）都可以被同步到任何你需要的地方。\n\n同步的过程是增量的。在数据库级别，同步只检查 documents 最后一次同步\n的更新。对于每一个更新的 document而言，只有有修改的fileds和blobs才\n会经网络上同步。如果因为网络问题或者崩溃等问题，同步过程在任何一个地方失败了，下一次同步重新开始于上次失败的同一个 document 。\n\n允许同步部分的 documents。可以通过javascript函数过滤出需要同步的 documents。这就允许用户获取一个含有大量数据的数据库应用的一个子集来离线使用。\n\n### 冲突\n\n冲突检查及管理是任何分布式更新系统的一个重要问题。CouchDB 存储系统\n把更新冲突视作一个普通的状态，而不是一个异常。在保留单 document 语义及允许去中心化的冲突解决的场景中，这种冲突处理模型是简单的，并且也是“非致命的”。\n\nCouchDB 允许在数据库中同时存在任意数量的有冲突的 documents，它让具体的数据库实例来决定哪些 document 是正确的，哪些是冲突的。只有正确的\ndocuments能够出现在视图中，而哪些冲突的 documents 仍然保留在数据库中，并且也可以被访问到，直到被删除或在数据库compaction过程中被清除。因为冲突的 documents 仍然是普通的 documents，所以它们也会按普通的documents 那样被同步，以及应用安全校验规则。\n\n当出现分布式的更新冲突时，每一个同步的数据库都会得到同一个正确的版本，然后都有机会去解决冲突。冲突的解决可以手动或者依赖某种数据特性来自动完成。\n\n当多个用户或者代理尝试解决同一个冲突时，冲突的管理仍然奏效。如果解决一个冲突而引起更多的冲突时，系统将会按同样的方式来调解。\n\n### 应用\n\n只使用基本的同步模型，不需要额外的工作就可以使很多单服务器数据库应用成为分布式的。CouchDB 的同步被设计为为基本的数据库应用提供开箱即用的功能。当然，也可以被拓展来满足更多特性的场景。\n\n只需要一点点数据库的工作，就可以构建一个分布式的，拥有细粒度安全控制和完整修订历史的文档管理应用。文档的修改可以被实现为field和blob的增\n量同步，这样，被同步的修改就接近于实际中的修改差异（“diffs”）的效率。\n\nCouchDB的同步模型可以为其它的分布式更新模型做相应修改。如果存储引擎\n允许多个 documents 的更新事务，那么当从上游服务器同步时，就可以执行类Subversion的“all or nothing”原子提交，那样，单个 document冲突或\n校验失败时都会导致整个更新失败。如同 Subversion，冲突是通过拉取同步\n来获取本地冲突，然后合并，最后同步回上游服务器来完成的。\n\n\n## 实现\n\nCouchDB 是构建于Erlang OTP（一个函数式，并发编程语言和开发平台）之上的。 Erlang是为需要高可靠性和高可用性的实时电信应用而开发的。\n\nErlang的语法和语义与传统的编程语言如C或者Java有很大的区别。Erlang\n使用轻量级的“进程”和消息传递机制来实现并发，它没有共享状态的线程机制，并且所有的数据都是不可变的。Erlang的健壮，并发特性非常适合数据库服务器。\n\nCouchDB被设计成类似Erlang的无锁并发的模型，实际上也正是用Erlang实现\n的。降低瓶颈及避免锁的使用，使得在高负载的情况下，整个系统的状态是\n可控的。不需要锁，CouchDB就可以满足多个客户端的同步修改，更新 documents，以及索引被其它客户端刷新的视图还可以同时被查询。\n\n为了更好的可用性及更多的并发支持，CouchDB还被设计为\"shared nothing\"\n集群。集群中的每台机器都是独立的，并从集群中的其它机器同步数据，这就允许单个服务器零时间的宕机。因为重启过程不需要一致性检查和修复，所以即使整个集群崩溃了——例如数据中心电力不足——整个CouchDB分布式系统在重\n启之后还是可以立刻服务。\n\nCouchDB 始于一个分布式文档数据库系统的一致性版本机制。CouchDB 不是在同样模型和数据库上组装一些分布式特性，而是从底层开始的工程。CouchDB\n把文档/视图/安全/同步模型，特定用途的查询语言，高效健壮的磁盘文件布\n局，以及Erlang平台的并发性和可靠性集中到一个系统当中。","source":"_posts/2014-06-23-technical-overview-of-couchdb.md","raw":"---\ntitle: \"[译] CouchDB 技术概述\"\ndate: 2014-06-23 16:32:14 +0800\ncategories: couchdb\n---\n[原文链接](http://docs.couchdb.org/en/latest/intro/overview.html)\n\n## Document 存储\n\n一个 CouchDB 服务器管理一些有名字的数据库，这些数据库里存储着称为\n`documents`的东西。每个 document 在数据库中被有一个唯一的名字，同\n时，CouchDB 提供了对其进行 reading 和 updating(add, edit, delete)\n操作的[RESTful](http://en.wikipedia.org/wiki/REST)\n[HTTP API](http://docs.couchdb.org/en/latest/api/basics.html#api-basics)。\n\nCouchDB 中数据的主要单元就是 document，它由任意数量的 field 和\nattachment 组成。document 还包含一个由数据库系统维护的自身元数据\n信息。document 的 field 是一些 name-value 对的集合，其中，name 是\n唯一的，value 可以为[各种类型](htp://docs.couchdb.org/en/latest/api/basics.html#json)(text, number, boolean, list等)，并且它们都是没\n有大小或数量限制的。\n\nCouchDB 的 document 更新模型是无锁的，乐观的。Document 的编辑流程\n通常是客户端应用先加载 documents，再应用一些变化，最后保存回数据库。\n如果在编辑的同时有另一个客户端先提交了保存，那么此时的修改会返回一\n个编辑冲突的错误。解决这种更新冲突的办法是，不指定 document 的最终\n版本，重新编辑提交一次。\n\nDocument 的更新操作（add, edit, delete）要么成功，要么失败。数据库\n是不会包含不完整的数据的。\n\n\n## ACID 特性\n\nCouchDB 文件布局和提交系统具备`Atomic Consistent Isolated Durable(ACID)`特性。在磁盘上，CouchDB绝不会覆盖已提交的数据或关联的结构，保证\n数据库文件状态总是一致性的。这是一种 `crash-only` 设计，当有进程挂掉时，CouchDB 不会做任何处理，只是简单的死去。\n\nDocument的更新（add, edit, delete）操作中，除了对`binary blobs` 数据\n是并发写的，其它都是顺序的。数据库读操作是立即执行的，不会加锁，也不会等待其他任何写操作或读操作完成的。即使对于同一个 document，多个客\n户端的读操作不会被加锁或者因并发更新而中断。CouchDB 的读操作使用了\n一种称为**[Multi-Version Concurrency Control](http://en.wikipedia.org/wiki/Multiversion_concurrency_control)**的模型，它保证每个客户端\n在读操作中，都可以获得数据库最新版本的一致性数据(see a consistent\nsnapshot of the database)。\n\nDocument 被索引在由它们的名字（DocID）和一个序列号构成的 B-trees 中\n。每一个更新都会产生一个新的序列号。序列号稍后被应用于数据库的增量\n变化中。当 document 被保存或删除时，这些 B-tree 索引都会被更新。索\n引的更新总是出现在索引文件的末尾（append-only更新）。\n\n在存储被适当包装的数据场景中，document 机制比在大多数数据库中把打\n包的数据切分成多个表和行来存储更有优势。当 document 数据被存储到磁盘时，document 的字段和元数据信息就被打包进缓冲中，同时，document 被\n顺序存放（方便后续高效地生成视图）。\n\n当 document 更新完成时，所有新的数据及关联的索引都会被刷入到磁盘，\n同时，事务提交总是保证数据库处于完全一致的状态中。提交出现在以下两步中：\n1. 所有的document数据及其索引的更新被同步刷入磁盘中。\n2. 数据库header的更新分成两步。先用一致的数据块填充文件的前4k空间，然后同步刷入磁盘中。\n\n如果在第1步中OS崩溃或发生断电了，被刷入的部分更新在重启时会被丢弃。\n如果这种情况发生在第2步当中（提交header），header的一份拷贝会被保留\n，来保证之前已提交数据的一致性。在发生崩溃或断电后，只会对header部分做一致性检查或修复。\n\n\n## Compaction\n\n浪费的空间会在精简过程中被释放。当数据库文件浪费的空间超过一定值时\n或者精简调度被触发，compaction 进程会复制数据库文件中的所有活跃数据\n到一个新的数据库文件中，然后丢弃旧的数据库文件。在整个期间，数据库\n的访问不会被中断。旧的数据库文件只会在当其所有的数据都被拷贝到新文件，并且用户的操作都过渡到新文件时才会被丢弃。\n\n\n## 视图\n\nACID 只能解决存储和更新的问题，但我们有时也需要按某种有用的方式来\n展示数据。CouchDB 不像 SQL 数据库那样必须小心地把数据切分到不同的表\n中，它会把数据存入半结构化的 documents中。CouchDB 的 document 是灵活的，并且它有一个隐式结构用来对付在表结构和数据的双向复制中\n的大多数难题和陷阱。\n\n但是，仅仅一个简单的 document 模型是很不够的。我们更多的是想要通过很多种不同的方式对我们的数据进行分析。对于这种没有按分类切分到不同的表中的数据，我们需要一种过滤，组织，报告的方式。\n\n### 视图模型\n\n为了解决给非结构化和半结构化的数据附加一种结构，CouchDB 集成了一种\n视图模型。视图是一种给 documents 做汇总和报告的方法。因为视图是动态\n构建的，并且不影响所依赖的 document，所以同一份数据可以有多种视图\n表示。\n视图的定义是完全虚拟的，并且只显示当前数据库实例的 documents，这就\n使视图与它所显示的数据本身隔离开来，并且也可以被复制。CouchDB 的视\n图被定义在一种特殊的`design documents`当中，并且也可以像普通的 documents那样被复制到不同的数据库实例当中。因此，在CouchDB中，不仅仅是数\n据可以被复制，整个应用的设计也可以被复制。\n\n### Javascript 视图函数\n\n视图的是通过在 map-reduce 系统中扮演map部分的 Javascript 函数来定义\n的。一个视图函数接受一个 CouchDB document作为参数，然后经过一些计算\n来决定这个数据是否是视图所需要的。可以给基于单 document 的视图添加\n多行，或者一行都不添加。\n\n### 视图索引\n\n视图是数据库真实 document 内容的一个动态表示，并且视图的创建也是非常容易的。为数据库中的大量 documents 生成一个视图是非常耗时的，所以系\n统不会每次都从头做起。\n\n为了提高视图的查询效率，视图引擎维护了一些视图的索引，并且增量更新\n它们以便反映数据库中的变化。CouchDB的核心设计是为效率的需要，大量\n优化视图及其索引的增量创建。\n\n视图及视图函数被定义在特殊“设计”的 documents，这样的一个 document\n包含了任意数量的视图函数。当一个用户使用一个视图时，视图的索引就会\n自动更新。一个 design document 中的所有视图作为一个组来索引。\n\n视图构建器使用序列号来决定视图组是否全部更新了。如果不是，视图引擎\n就会检查自上次刷新视图组后的全部 documents 变化（按数据打包序列顺\n序）。Documents 按照它们在磁盘文件出现的顺序开始读，减少磁头寻道频\n率。\n\n当视图被刷新时，仍然可以被同时读和查询。如果某个客户端从一个大视图\n中很慢地获取数据时，视图仍然可以被其他的客户端使用和刷新，且不会阻塞\n先前正在使用的客户端。视图索引刷新的同时，大量对视图的读和查询操作是不会有任何问题的。\n\n由于 documents 是被视图引擎调用用户定义的map/reduce函数来处理的，它\n们先前的行将从视图索引中移除。当视图函数操作一个 document 时， 函数\n返回结果将作为一个新的行被插入到视图中。\n\n视图索引的修改总是被写入到磁盘文件的末尾，来减少磁头寻道时间，以及保证在发生崩溃和断电时的写不会搞坏已有的索引。当崩溃发生在更新索引的过程中，未完成的索引修改将被简单的丢弃，并根据先前的提交状态重新构建索引增量。\n\n\n## 安全和校验\n\n对于需要读及更新 documents 的工程，CouchDB 提供了一个简单的读访问控\n制及更新校验的模型来被拓展以实现自定义的安全模型。\n\n### 管理员访问控制\n\nCouchDB 数据库提供了管理员账户。管理员账户可以创建其他的管理员账号，并且可以更新 design documents。Design documents是一种包含了视图定义\n及其他信息的特殊的 documents。\n\n### 更新校验\n\n由于 document 被写入到磁盘中，它们可以被javascript函数动态校验。当\ndocument 通过了所有的校验规则时，则更新操作被允许。如果校验失败，更\n新操作将被中止，同时用户客户端将返回一个错误响应。\n\n校验规则需要用户的认证信息及将被更新的 document 作为输入，我们可以\n通过验证用户的权限来实现自定义的 document 更新的安全模型。\n\nCouchDB 提供了一个基本的`author only`的 document 更新模型，它会校验\n用户是否在 document 的`author`字段中。更动态的校验模型也是可以的，\n比如检查一个单独的用户账户信息来判断权限。\n\n\n## 分布式更新及同步\n\nCouchDB 是一个基于对等的分布式数据库系统。它允许用户和服务器在未连接时也能访问和更新同一份数据。各自所做的修改可以在后续进行双向同步。\n\nCouchDB的 document 存储，视图，及安全模型被设计来共同实现真正高效的\n，可靠的双向同步。Documents 和 design documents都可以被同步，这就\n允许全部的数据库应用（包括应用设计，逻辑及数据）都可以被同步到任何你需要的地方。\n\n同步的过程是增量的。在数据库级别，同步只检查 documents 最后一次同步\n的更新。对于每一个更新的 document而言，只有有修改的fileds和blobs才\n会经网络上同步。如果因为网络问题或者崩溃等问题，同步过程在任何一个地方失败了，下一次同步重新开始于上次失败的同一个 document 。\n\n允许同步部分的 documents。可以通过javascript函数过滤出需要同步的 documents。这就允许用户获取一个含有大量数据的数据库应用的一个子集来离线使用。\n\n### 冲突\n\n冲突检查及管理是任何分布式更新系统的一个重要问题。CouchDB 存储系统\n把更新冲突视作一个普通的状态，而不是一个异常。在保留单 document 语义及允许去中心化的冲突解决的场景中，这种冲突处理模型是简单的，并且也是“非致命的”。\n\nCouchDB 允许在数据库中同时存在任意数量的有冲突的 documents，它让具体的数据库实例来决定哪些 document 是正确的，哪些是冲突的。只有正确的\ndocuments能够出现在视图中，而哪些冲突的 documents 仍然保留在数据库中，并且也可以被访问到，直到被删除或在数据库compaction过程中被清除。因为冲突的 documents 仍然是普通的 documents，所以它们也会按普通的documents 那样被同步，以及应用安全校验规则。\n\n当出现分布式的更新冲突时，每一个同步的数据库都会得到同一个正确的版本，然后都有机会去解决冲突。冲突的解决可以手动或者依赖某种数据特性来自动完成。\n\n当多个用户或者代理尝试解决同一个冲突时，冲突的管理仍然奏效。如果解决一个冲突而引起更多的冲突时，系统将会按同样的方式来调解。\n\n### 应用\n\n只使用基本的同步模型，不需要额外的工作就可以使很多单服务器数据库应用成为分布式的。CouchDB 的同步被设计为为基本的数据库应用提供开箱即用的功能。当然，也可以被拓展来满足更多特性的场景。\n\n只需要一点点数据库的工作，就可以构建一个分布式的，拥有细粒度安全控制和完整修订历史的文档管理应用。文档的修改可以被实现为field和blob的增\n量同步，这样，被同步的修改就接近于实际中的修改差异（“diffs”）的效率。\n\nCouchDB的同步模型可以为其它的分布式更新模型做相应修改。如果存储引擎\n允许多个 documents 的更新事务，那么当从上游服务器同步时，就可以执行类Subversion的“all or nothing”原子提交，那样，单个 document冲突或\n校验失败时都会导致整个更新失败。如同 Subversion，冲突是通过拉取同步\n来获取本地冲突，然后合并，最后同步回上游服务器来完成的。\n\n\n## 实现\n\nCouchDB 是构建于Erlang OTP（一个函数式，并发编程语言和开发平台）之上的。 Erlang是为需要高可靠性和高可用性的实时电信应用而开发的。\n\nErlang的语法和语义与传统的编程语言如C或者Java有很大的区别。Erlang\n使用轻量级的“进程”和消息传递机制来实现并发，它没有共享状态的线程机制，并且所有的数据都是不可变的。Erlang的健壮，并发特性非常适合数据库服务器。\n\nCouchDB被设计成类似Erlang的无锁并发的模型，实际上也正是用Erlang实现\n的。降低瓶颈及避免锁的使用，使得在高负载的情况下，整个系统的状态是\n可控的。不需要锁，CouchDB就可以满足多个客户端的同步修改，更新 documents，以及索引被其它客户端刷新的视图还可以同时被查询。\n\n为了更好的可用性及更多的并发支持，CouchDB还被设计为\"shared nothing\"\n集群。集群中的每台机器都是独立的，并从集群中的其它机器同步数据，这就允许单个服务器零时间的宕机。因为重启过程不需要一致性检查和修复，所以即使整个集群崩溃了——例如数据中心电力不足——整个CouchDB分布式系统在重\n启之后还是可以立刻服务。\n\nCouchDB 始于一个分布式文档数据库系统的一致性版本机制。CouchDB 不是在同样模型和数据库上组装一些分布式特性，而是从底层开始的工程。CouchDB\n把文档/视图/安全/同步模型，特定用途的查询语言，高效健壮的磁盘文件布\n局，以及Erlang平台的并发性和可靠性集中到一个系统当中。","slug":"technical-overview-of-couchdb","published":1,"updated":"2017-12-26T11:21:51.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbnjnr9r0005v4tnbtqmx8xx","content":"<p><a href=\"http://docs.couchdb.org/en/latest/intro/overview.html\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"Document-存储\"><a href=\"#Document-存储\" class=\"headerlink\" title=\"Document 存储\"></a>Document 存储</h2><p>一个 CouchDB 服务器管理一些有名字的数据库，这些数据库里存储着称为<br><code>documents</code>的东西。每个 document 在数据库中被有一个唯一的名字，同<br>时，CouchDB 提供了对其进行 reading 和 updating(add, edit, delete)<br>操作的<a href=\"http://en.wikipedia.org/wiki/REST\" target=\"_blank\" rel=\"noopener\">RESTful</a><br><a href=\"http://docs.couchdb.org/en/latest/api/basics.html#api-basics\" target=\"_blank\" rel=\"noopener\">HTTP API</a>。</p>\n<p>CouchDB 中数据的主要单元就是 document，它由任意数量的 field 和<br>attachment 组成。document 还包含一个由数据库系统维护的自身元数据<br>信息。document 的 field 是一些 name-value 对的集合，其中，name 是<br>唯一的，value 可以为<a href=\"htp://docs.couchdb.org/en/latest/api/basics.html#json\" target=\"_blank\" rel=\"noopener\">各种类型</a>(text, number, boolean, list等)，并且它们都是没<br>有大小或数量限制的。</p>\n<p>CouchDB 的 document 更新模型是无锁的，乐观的。Document 的编辑流程<br>通常是客户端应用先加载 documents，再应用一些变化，最后保存回数据库。<br>如果在编辑的同时有另一个客户端先提交了保存，那么此时的修改会返回一<br>个编辑冲突的错误。解决这种更新冲突的办法是，不指定 document 的最终<br>版本，重新编辑提交一次。</p>\n<p>Document 的更新操作（add, edit, delete）要么成功，要么失败。数据库<br>是不会包含不完整的数据的。</p>\n<h2 id=\"ACID-特性\"><a href=\"#ACID-特性\" class=\"headerlink\" title=\"ACID 特性\"></a>ACID 特性</h2><p>CouchDB 文件布局和提交系统具备<code>Atomic Consistent Isolated Durable(ACID)</code>特性。在磁盘上，CouchDB绝不会覆盖已提交的数据或关联的结构，保证<br>数据库文件状态总是一致性的。这是一种 <code>crash-only</code> 设计，当有进程挂掉时，CouchDB 不会做任何处理，只是简单的死去。</p>\n<p>Document的更新（add, edit, delete）操作中，除了对<code>binary blobs</code> 数据<br>是并发写的，其它都是顺序的。数据库读操作是立即执行的，不会加锁，也不会等待其他任何写操作或读操作完成的。即使对于同一个 document，多个客<br>户端的读操作不会被加锁或者因并发更新而中断。CouchDB 的读操作使用了<br>一种称为<strong><a href=\"http://en.wikipedia.org/wiki/Multiversion_concurrency_control\" target=\"_blank\" rel=\"noopener\">Multi-Version Concurrency Control</a></strong>的模型，它保证每个客户端<br>在读操作中，都可以获得数据库最新版本的一致性数据(see a consistent<br>snapshot of the database)。</p>\n<p>Document 被索引在由它们的名字（DocID）和一个序列号构成的 B-trees 中<br>。每一个更新都会产生一个新的序列号。序列号稍后被应用于数据库的增量<br>变化中。当 document 被保存或删除时，这些 B-tree 索引都会被更新。索<br>引的更新总是出现在索引文件的末尾（append-only更新）。</p>\n<p>在存储被适当包装的数据场景中，document 机制比在大多数数据库中把打<br>包的数据切分成多个表和行来存储更有优势。当 document 数据被存储到磁盘时，document 的字段和元数据信息就被打包进缓冲中，同时，document 被<br>顺序存放（方便后续高效地生成视图）。</p>\n<p>当 document 更新完成时，所有新的数据及关联的索引都会被刷入到磁盘，<br>同时，事务提交总是保证数据库处于完全一致的状态中。提交出现在以下两步中：</p>\n<ol>\n<li>所有的document数据及其索引的更新被同步刷入磁盘中。</li>\n<li>数据库header的更新分成两步。先用一致的数据块填充文件的前4k空间，然后同步刷入磁盘中。</li>\n</ol>\n<p>如果在第1步中OS崩溃或发生断电了，被刷入的部分更新在重启时会被丢弃。<br>如果这种情况发生在第2步当中（提交header），header的一份拷贝会被保留<br>，来保证之前已提交数据的一致性。在发生崩溃或断电后，只会对header部分做一致性检查或修复。</p>\n<h2 id=\"Compaction\"><a href=\"#Compaction\" class=\"headerlink\" title=\"Compaction\"></a>Compaction</h2><p>浪费的空间会在精简过程中被释放。当数据库文件浪费的空间超过一定值时<br>或者精简调度被触发，compaction 进程会复制数据库文件中的所有活跃数据<br>到一个新的数据库文件中，然后丢弃旧的数据库文件。在整个期间，数据库<br>的访问不会被中断。旧的数据库文件只会在当其所有的数据都被拷贝到新文件，并且用户的操作都过渡到新文件时才会被丢弃。</p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>ACID 只能解决存储和更新的问题，但我们有时也需要按某种有用的方式来<br>展示数据。CouchDB 不像 SQL 数据库那样必须小心地把数据切分到不同的表<br>中，它会把数据存入半结构化的 documents中。CouchDB 的 document 是灵活的，并且它有一个隐式结构用来对付在表结构和数据的双向复制中<br>的大多数难题和陷阱。</p>\n<p>但是，仅仅一个简单的 document 模型是很不够的。我们更多的是想要通过很多种不同的方式对我们的数据进行分析。对于这种没有按分类切分到不同的表中的数据，我们需要一种过滤，组织，报告的方式。</p>\n<h3 id=\"视图模型\"><a href=\"#视图模型\" class=\"headerlink\" title=\"视图模型\"></a>视图模型</h3><p>为了解决给非结构化和半结构化的数据附加一种结构，CouchDB 集成了一种<br>视图模型。视图是一种给 documents 做汇总和报告的方法。因为视图是动态<br>构建的，并且不影响所依赖的 document，所以同一份数据可以有多种视图<br>表示。<br>视图的定义是完全虚拟的，并且只显示当前数据库实例的 documents，这就<br>使视图与它所显示的数据本身隔离开来，并且也可以被复制。CouchDB 的视<br>图被定义在一种特殊的<code>design documents</code>当中，并且也可以像普通的 documents那样被复制到不同的数据库实例当中。因此，在CouchDB中，不仅仅是数<br>据可以被复制，整个应用的设计也可以被复制。</p>\n<h3 id=\"Javascript-视图函数\"><a href=\"#Javascript-视图函数\" class=\"headerlink\" title=\"Javascript 视图函数\"></a>Javascript 视图函数</h3><p>视图的是通过在 map-reduce 系统中扮演map部分的 Javascript 函数来定义<br>的。一个视图函数接受一个 CouchDB document作为参数，然后经过一些计算<br>来决定这个数据是否是视图所需要的。可以给基于单 document 的视图添加<br>多行，或者一行都不添加。</p>\n<h3 id=\"视图索引\"><a href=\"#视图索引\" class=\"headerlink\" title=\"视图索引\"></a>视图索引</h3><p>视图是数据库真实 document 内容的一个动态表示，并且视图的创建也是非常容易的。为数据库中的大量 documents 生成一个视图是非常耗时的，所以系<br>统不会每次都从头做起。</p>\n<p>为了提高视图的查询效率，视图引擎维护了一些视图的索引，并且增量更新<br>它们以便反映数据库中的变化。CouchDB的核心设计是为效率的需要，大量<br>优化视图及其索引的增量创建。</p>\n<p>视图及视图函数被定义在特殊“设计”的 documents，这样的一个 document<br>包含了任意数量的视图函数。当一个用户使用一个视图时，视图的索引就会<br>自动更新。一个 design document 中的所有视图作为一个组来索引。</p>\n<p>视图构建器使用序列号来决定视图组是否全部更新了。如果不是，视图引擎<br>就会检查自上次刷新视图组后的全部 documents 变化（按数据打包序列顺<br>序）。Documents 按照它们在磁盘文件出现的顺序开始读，减少磁头寻道频<br>率。</p>\n<p>当视图被刷新时，仍然可以被同时读和查询。如果某个客户端从一个大视图<br>中很慢地获取数据时，视图仍然可以被其他的客户端使用和刷新，且不会阻塞<br>先前正在使用的客户端。视图索引刷新的同时，大量对视图的读和查询操作是不会有任何问题的。</p>\n<p>由于 documents 是被视图引擎调用用户定义的map/reduce函数来处理的，它<br>们先前的行将从视图索引中移除。当视图函数操作一个 document 时， 函数<br>返回结果将作为一个新的行被插入到视图中。</p>\n<p>视图索引的修改总是被写入到磁盘文件的末尾，来减少磁头寻道时间，以及保证在发生崩溃和断电时的写不会搞坏已有的索引。当崩溃发生在更新索引的过程中，未完成的索引修改将被简单的丢弃，并根据先前的提交状态重新构建索引增量。</p>\n<h2 id=\"安全和校验\"><a href=\"#安全和校验\" class=\"headerlink\" title=\"安全和校验\"></a>安全和校验</h2><p>对于需要读及更新 documents 的工程，CouchDB 提供了一个简单的读访问控<br>制及更新校验的模型来被拓展以实现自定义的安全模型。</p>\n<h3 id=\"管理员访问控制\"><a href=\"#管理员访问控制\" class=\"headerlink\" title=\"管理员访问控制\"></a>管理员访问控制</h3><p>CouchDB 数据库提供了管理员账户。管理员账户可以创建其他的管理员账号，并且可以更新 design documents。Design documents是一种包含了视图定义<br>及其他信息的特殊的 documents。</p>\n<h3 id=\"更新校验\"><a href=\"#更新校验\" class=\"headerlink\" title=\"更新校验\"></a>更新校验</h3><p>由于 document 被写入到磁盘中，它们可以被javascript函数动态校验。当<br>document 通过了所有的校验规则时，则更新操作被允许。如果校验失败，更<br>新操作将被中止，同时用户客户端将返回一个错误响应。</p>\n<p>校验规则需要用户的认证信息及将被更新的 document 作为输入，我们可以<br>通过验证用户的权限来实现自定义的 document 更新的安全模型。</p>\n<p>CouchDB 提供了一个基本的<code>author only</code>的 document 更新模型，它会校验<br>用户是否在 document 的<code>author</code>字段中。更动态的校验模型也是可以的，<br>比如检查一个单独的用户账户信息来判断权限。</p>\n<h2 id=\"分布式更新及同步\"><a href=\"#分布式更新及同步\" class=\"headerlink\" title=\"分布式更新及同步\"></a>分布式更新及同步</h2><p>CouchDB 是一个基于对等的分布式数据库系统。它允许用户和服务器在未连接时也能访问和更新同一份数据。各自所做的修改可以在后续进行双向同步。</p>\n<p>CouchDB的 document 存储，视图，及安全模型被设计来共同实现真正高效的<br>，可靠的双向同步。Documents 和 design documents都可以被同步，这就<br>允许全部的数据库应用（包括应用设计，逻辑及数据）都可以被同步到任何你需要的地方。</p>\n<p>同步的过程是增量的。在数据库级别，同步只检查 documents 最后一次同步<br>的更新。对于每一个更新的 document而言，只有有修改的fileds和blobs才<br>会经网络上同步。如果因为网络问题或者崩溃等问题，同步过程在任何一个地方失败了，下一次同步重新开始于上次失败的同一个 document 。</p>\n<p>允许同步部分的 documents。可以通过javascript函数过滤出需要同步的 documents。这就允许用户获取一个含有大量数据的数据库应用的一个子集来离线使用。</p>\n<h3 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h3><p>冲突检查及管理是任何分布式更新系统的一个重要问题。CouchDB 存储系统<br>把更新冲突视作一个普通的状态，而不是一个异常。在保留单 document 语义及允许去中心化的冲突解决的场景中，这种冲突处理模型是简单的，并且也是“非致命的”。</p>\n<p>CouchDB 允许在数据库中同时存在任意数量的有冲突的 documents，它让具体的数据库实例来决定哪些 document 是正确的，哪些是冲突的。只有正确的<br>documents能够出现在视图中，而哪些冲突的 documents 仍然保留在数据库中，并且也可以被访问到，直到被删除或在数据库compaction过程中被清除。因为冲突的 documents 仍然是普通的 documents，所以它们也会按普通的documents 那样被同步，以及应用安全校验规则。</p>\n<p>当出现分布式的更新冲突时，每一个同步的数据库都会得到同一个正确的版本，然后都有机会去解决冲突。冲突的解决可以手动或者依赖某种数据特性来自动完成。</p>\n<p>当多个用户或者代理尝试解决同一个冲突时，冲突的管理仍然奏效。如果解决一个冲突而引起更多的冲突时，系统将会按同样的方式来调解。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>只使用基本的同步模型，不需要额外的工作就可以使很多单服务器数据库应用成为分布式的。CouchDB 的同步被设计为为基本的数据库应用提供开箱即用的功能。当然，也可以被拓展来满足更多特性的场景。</p>\n<p>只需要一点点数据库的工作，就可以构建一个分布式的，拥有细粒度安全控制和完整修订历史的文档管理应用。文档的修改可以被实现为field和blob的增<br>量同步，这样，被同步的修改就接近于实际中的修改差异（“diffs”）的效率。</p>\n<p>CouchDB的同步模型可以为其它的分布式更新模型做相应修改。如果存储引擎<br>允许多个 documents 的更新事务，那么当从上游服务器同步时，就可以执行类Subversion的“all or nothing”原子提交，那样，单个 document冲突或<br>校验失败时都会导致整个更新失败。如同 Subversion，冲突是通过拉取同步<br>来获取本地冲突，然后合并，最后同步回上游服务器来完成的。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>CouchDB 是构建于Erlang OTP（一个函数式，并发编程语言和开发平台）之上的。 Erlang是为需要高可靠性和高可用性的实时电信应用而开发的。</p>\n<p>Erlang的语法和语义与传统的编程语言如C或者Java有很大的区别。Erlang<br>使用轻量级的“进程”和消息传递机制来实现并发，它没有共享状态的线程机制，并且所有的数据都是不可变的。Erlang的健壮，并发特性非常适合数据库服务器。</p>\n<p>CouchDB被设计成类似Erlang的无锁并发的模型，实际上也正是用Erlang实现<br>的。降低瓶颈及避免锁的使用，使得在高负载的情况下，整个系统的状态是<br>可控的。不需要锁，CouchDB就可以满足多个客户端的同步修改，更新 documents，以及索引被其它客户端刷新的视图还可以同时被查询。</p>\n<p>为了更好的可用性及更多的并发支持，CouchDB还被设计为”shared nothing”<br>集群。集群中的每台机器都是独立的，并从集群中的其它机器同步数据，这就允许单个服务器零时间的宕机。因为重启过程不需要一致性检查和修复，所以即使整个集群崩溃了——例如数据中心电力不足——整个CouchDB分布式系统在重<br>启之后还是可以立刻服务。</p>\n<p>CouchDB 始于一个分布式文档数据库系统的一致性版本机制。CouchDB 不是在同样模型和数据库上组装一些分布式特性，而是从底层开始的工程。CouchDB<br>把文档/视图/安全/同步模型，特定用途的查询语言，高效健壮的磁盘文件布<br>局，以及Erlang平台的并发性和可靠性集中到一个系统当中。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://docs.couchdb.org/en/latest/intro/overview.html\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"Document-存储\"><a href=\"#Document-存储\" class=\"headerlink\" title=\"Document 存储\"></a>Document 存储</h2><p>一个 CouchDB 服务器管理一些有名字的数据库，这些数据库里存储着称为<br><code>documents</code>的东西。每个 document 在数据库中被有一个唯一的名字，同<br>时，CouchDB 提供了对其进行 reading 和 updating(add, edit, delete)<br>操作的<a href=\"http://en.wikipedia.org/wiki/REST\" target=\"_blank\" rel=\"noopener\">RESTful</a><br><a href=\"http://docs.couchdb.org/en/latest/api/basics.html#api-basics\" target=\"_blank\" rel=\"noopener\">HTTP API</a>。</p>\n<p>CouchDB 中数据的主要单元就是 document，它由任意数量的 field 和<br>attachment 组成。document 还包含一个由数据库系统维护的自身元数据<br>信息。document 的 field 是一些 name-value 对的集合，其中，name 是<br>唯一的，value 可以为<a href=\"htp://docs.couchdb.org/en/latest/api/basics.html#json\" target=\"_blank\" rel=\"noopener\">各种类型</a>(text, number, boolean, list等)，并且它们都是没<br>有大小或数量限制的。</p>\n<p>CouchDB 的 document 更新模型是无锁的，乐观的。Document 的编辑流程<br>通常是客户端应用先加载 documents，再应用一些变化，最后保存回数据库。<br>如果在编辑的同时有另一个客户端先提交了保存，那么此时的修改会返回一<br>个编辑冲突的错误。解决这种更新冲突的办法是，不指定 document 的最终<br>版本，重新编辑提交一次。</p>\n<p>Document 的更新操作（add, edit, delete）要么成功，要么失败。数据库<br>是不会包含不完整的数据的。</p>\n<h2 id=\"ACID-特性\"><a href=\"#ACID-特性\" class=\"headerlink\" title=\"ACID 特性\"></a>ACID 特性</h2><p>CouchDB 文件布局和提交系统具备<code>Atomic Consistent Isolated Durable(ACID)</code>特性。在磁盘上，CouchDB绝不会覆盖已提交的数据或关联的结构，保证<br>数据库文件状态总是一致性的。这是一种 <code>crash-only</code> 设计，当有进程挂掉时，CouchDB 不会做任何处理，只是简单的死去。</p>\n<p>Document的更新（add, edit, delete）操作中，除了对<code>binary blobs</code> 数据<br>是并发写的，其它都是顺序的。数据库读操作是立即执行的，不会加锁，也不会等待其他任何写操作或读操作完成的。即使对于同一个 document，多个客<br>户端的读操作不会被加锁或者因并发更新而中断。CouchDB 的读操作使用了<br>一种称为<strong><a href=\"http://en.wikipedia.org/wiki/Multiversion_concurrency_control\" target=\"_blank\" rel=\"noopener\">Multi-Version Concurrency Control</a></strong>的模型，它保证每个客户端<br>在读操作中，都可以获得数据库最新版本的一致性数据(see a consistent<br>snapshot of the database)。</p>\n<p>Document 被索引在由它们的名字（DocID）和一个序列号构成的 B-trees 中<br>。每一个更新都会产生一个新的序列号。序列号稍后被应用于数据库的增量<br>变化中。当 document 被保存或删除时，这些 B-tree 索引都会被更新。索<br>引的更新总是出现在索引文件的末尾（append-only更新）。</p>\n<p>在存储被适当包装的数据场景中，document 机制比在大多数数据库中把打<br>包的数据切分成多个表和行来存储更有优势。当 document 数据被存储到磁盘时，document 的字段和元数据信息就被打包进缓冲中，同时，document 被<br>顺序存放（方便后续高效地生成视图）。</p>\n<p>当 document 更新完成时，所有新的数据及关联的索引都会被刷入到磁盘，<br>同时，事务提交总是保证数据库处于完全一致的状态中。提交出现在以下两步中：</p>\n<ol>\n<li>所有的document数据及其索引的更新被同步刷入磁盘中。</li>\n<li>数据库header的更新分成两步。先用一致的数据块填充文件的前4k空间，然后同步刷入磁盘中。</li>\n</ol>\n<p>如果在第1步中OS崩溃或发生断电了，被刷入的部分更新在重启时会被丢弃。<br>如果这种情况发生在第2步当中（提交header），header的一份拷贝会被保留<br>，来保证之前已提交数据的一致性。在发生崩溃或断电后，只会对header部分做一致性检查或修复。</p>\n<h2 id=\"Compaction\"><a href=\"#Compaction\" class=\"headerlink\" title=\"Compaction\"></a>Compaction</h2><p>浪费的空间会在精简过程中被释放。当数据库文件浪费的空间超过一定值时<br>或者精简调度被触发，compaction 进程会复制数据库文件中的所有活跃数据<br>到一个新的数据库文件中，然后丢弃旧的数据库文件。在整个期间，数据库<br>的访问不会被中断。旧的数据库文件只会在当其所有的数据都被拷贝到新文件，并且用户的操作都过渡到新文件时才会被丢弃。</p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>ACID 只能解决存储和更新的问题，但我们有时也需要按某种有用的方式来<br>展示数据。CouchDB 不像 SQL 数据库那样必须小心地把数据切分到不同的表<br>中，它会把数据存入半结构化的 documents中。CouchDB 的 document 是灵活的，并且它有一个隐式结构用来对付在表结构和数据的双向复制中<br>的大多数难题和陷阱。</p>\n<p>但是，仅仅一个简单的 document 模型是很不够的。我们更多的是想要通过很多种不同的方式对我们的数据进行分析。对于这种没有按分类切分到不同的表中的数据，我们需要一种过滤，组织，报告的方式。</p>\n<h3 id=\"视图模型\"><a href=\"#视图模型\" class=\"headerlink\" title=\"视图模型\"></a>视图模型</h3><p>为了解决给非结构化和半结构化的数据附加一种结构，CouchDB 集成了一种<br>视图模型。视图是一种给 documents 做汇总和报告的方法。因为视图是动态<br>构建的，并且不影响所依赖的 document，所以同一份数据可以有多种视图<br>表示。<br>视图的定义是完全虚拟的，并且只显示当前数据库实例的 documents，这就<br>使视图与它所显示的数据本身隔离开来，并且也可以被复制。CouchDB 的视<br>图被定义在一种特殊的<code>design documents</code>当中，并且也可以像普通的 documents那样被复制到不同的数据库实例当中。因此，在CouchDB中，不仅仅是数<br>据可以被复制，整个应用的设计也可以被复制。</p>\n<h3 id=\"Javascript-视图函数\"><a href=\"#Javascript-视图函数\" class=\"headerlink\" title=\"Javascript 视图函数\"></a>Javascript 视图函数</h3><p>视图的是通过在 map-reduce 系统中扮演map部分的 Javascript 函数来定义<br>的。一个视图函数接受一个 CouchDB document作为参数，然后经过一些计算<br>来决定这个数据是否是视图所需要的。可以给基于单 document 的视图添加<br>多行，或者一行都不添加。</p>\n<h3 id=\"视图索引\"><a href=\"#视图索引\" class=\"headerlink\" title=\"视图索引\"></a>视图索引</h3><p>视图是数据库真实 document 内容的一个动态表示，并且视图的创建也是非常容易的。为数据库中的大量 documents 生成一个视图是非常耗时的，所以系<br>统不会每次都从头做起。</p>\n<p>为了提高视图的查询效率，视图引擎维护了一些视图的索引，并且增量更新<br>它们以便反映数据库中的变化。CouchDB的核心设计是为效率的需要，大量<br>优化视图及其索引的增量创建。</p>\n<p>视图及视图函数被定义在特殊“设计”的 documents，这样的一个 document<br>包含了任意数量的视图函数。当一个用户使用一个视图时，视图的索引就会<br>自动更新。一个 design document 中的所有视图作为一个组来索引。</p>\n<p>视图构建器使用序列号来决定视图组是否全部更新了。如果不是，视图引擎<br>就会检查自上次刷新视图组后的全部 documents 变化（按数据打包序列顺<br>序）。Documents 按照它们在磁盘文件出现的顺序开始读，减少磁头寻道频<br>率。</p>\n<p>当视图被刷新时，仍然可以被同时读和查询。如果某个客户端从一个大视图<br>中很慢地获取数据时，视图仍然可以被其他的客户端使用和刷新，且不会阻塞<br>先前正在使用的客户端。视图索引刷新的同时，大量对视图的读和查询操作是不会有任何问题的。</p>\n<p>由于 documents 是被视图引擎调用用户定义的map/reduce函数来处理的，它<br>们先前的行将从视图索引中移除。当视图函数操作一个 document 时， 函数<br>返回结果将作为一个新的行被插入到视图中。</p>\n<p>视图索引的修改总是被写入到磁盘文件的末尾，来减少磁头寻道时间，以及保证在发生崩溃和断电时的写不会搞坏已有的索引。当崩溃发生在更新索引的过程中，未完成的索引修改将被简单的丢弃，并根据先前的提交状态重新构建索引增量。</p>\n<h2 id=\"安全和校验\"><a href=\"#安全和校验\" class=\"headerlink\" title=\"安全和校验\"></a>安全和校验</h2><p>对于需要读及更新 documents 的工程，CouchDB 提供了一个简单的读访问控<br>制及更新校验的模型来被拓展以实现自定义的安全模型。</p>\n<h3 id=\"管理员访问控制\"><a href=\"#管理员访问控制\" class=\"headerlink\" title=\"管理员访问控制\"></a>管理员访问控制</h3><p>CouchDB 数据库提供了管理员账户。管理员账户可以创建其他的管理员账号，并且可以更新 design documents。Design documents是一种包含了视图定义<br>及其他信息的特殊的 documents。</p>\n<h3 id=\"更新校验\"><a href=\"#更新校验\" class=\"headerlink\" title=\"更新校验\"></a>更新校验</h3><p>由于 document 被写入到磁盘中，它们可以被javascript函数动态校验。当<br>document 通过了所有的校验规则时，则更新操作被允许。如果校验失败，更<br>新操作将被中止，同时用户客户端将返回一个错误响应。</p>\n<p>校验规则需要用户的认证信息及将被更新的 document 作为输入，我们可以<br>通过验证用户的权限来实现自定义的 document 更新的安全模型。</p>\n<p>CouchDB 提供了一个基本的<code>author only</code>的 document 更新模型，它会校验<br>用户是否在 document 的<code>author</code>字段中。更动态的校验模型也是可以的，<br>比如检查一个单独的用户账户信息来判断权限。</p>\n<h2 id=\"分布式更新及同步\"><a href=\"#分布式更新及同步\" class=\"headerlink\" title=\"分布式更新及同步\"></a>分布式更新及同步</h2><p>CouchDB 是一个基于对等的分布式数据库系统。它允许用户和服务器在未连接时也能访问和更新同一份数据。各自所做的修改可以在后续进行双向同步。</p>\n<p>CouchDB的 document 存储，视图，及安全模型被设计来共同实现真正高效的<br>，可靠的双向同步。Documents 和 design documents都可以被同步，这就<br>允许全部的数据库应用（包括应用设计，逻辑及数据）都可以被同步到任何你需要的地方。</p>\n<p>同步的过程是增量的。在数据库级别，同步只检查 documents 最后一次同步<br>的更新。对于每一个更新的 document而言，只有有修改的fileds和blobs才<br>会经网络上同步。如果因为网络问题或者崩溃等问题，同步过程在任何一个地方失败了，下一次同步重新开始于上次失败的同一个 document 。</p>\n<p>允许同步部分的 documents。可以通过javascript函数过滤出需要同步的 documents。这就允许用户获取一个含有大量数据的数据库应用的一个子集来离线使用。</p>\n<h3 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h3><p>冲突检查及管理是任何分布式更新系统的一个重要问题。CouchDB 存储系统<br>把更新冲突视作一个普通的状态，而不是一个异常。在保留单 document 语义及允许去中心化的冲突解决的场景中，这种冲突处理模型是简单的，并且也是“非致命的”。</p>\n<p>CouchDB 允许在数据库中同时存在任意数量的有冲突的 documents，它让具体的数据库实例来决定哪些 document 是正确的，哪些是冲突的。只有正确的<br>documents能够出现在视图中，而哪些冲突的 documents 仍然保留在数据库中，并且也可以被访问到，直到被删除或在数据库compaction过程中被清除。因为冲突的 documents 仍然是普通的 documents，所以它们也会按普通的documents 那样被同步，以及应用安全校验规则。</p>\n<p>当出现分布式的更新冲突时，每一个同步的数据库都会得到同一个正确的版本，然后都有机会去解决冲突。冲突的解决可以手动或者依赖某种数据特性来自动完成。</p>\n<p>当多个用户或者代理尝试解决同一个冲突时，冲突的管理仍然奏效。如果解决一个冲突而引起更多的冲突时，系统将会按同样的方式来调解。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>只使用基本的同步模型，不需要额外的工作就可以使很多单服务器数据库应用成为分布式的。CouchDB 的同步被设计为为基本的数据库应用提供开箱即用的功能。当然，也可以被拓展来满足更多特性的场景。</p>\n<p>只需要一点点数据库的工作，就可以构建一个分布式的，拥有细粒度安全控制和完整修订历史的文档管理应用。文档的修改可以被实现为field和blob的增<br>量同步，这样，被同步的修改就接近于实际中的修改差异（“diffs”）的效率。</p>\n<p>CouchDB的同步模型可以为其它的分布式更新模型做相应修改。如果存储引擎<br>允许多个 documents 的更新事务，那么当从上游服务器同步时，就可以执行类Subversion的“all or nothing”原子提交，那样，单个 document冲突或<br>校验失败时都会导致整个更新失败。如同 Subversion，冲突是通过拉取同步<br>来获取本地冲突，然后合并，最后同步回上游服务器来完成的。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>CouchDB 是构建于Erlang OTP（一个函数式，并发编程语言和开发平台）之上的。 Erlang是为需要高可靠性和高可用性的实时电信应用而开发的。</p>\n<p>Erlang的语法和语义与传统的编程语言如C或者Java有很大的区别。Erlang<br>使用轻量级的“进程”和消息传递机制来实现并发，它没有共享状态的线程机制，并且所有的数据都是不可变的。Erlang的健壮，并发特性非常适合数据库服务器。</p>\n<p>CouchDB被设计成类似Erlang的无锁并发的模型，实际上也正是用Erlang实现<br>的。降低瓶颈及避免锁的使用，使得在高负载的情况下，整个系统的状态是<br>可控的。不需要锁，CouchDB就可以满足多个客户端的同步修改，更新 documents，以及索引被其它客户端刷新的视图还可以同时被查询。</p>\n<p>为了更好的可用性及更多的并发支持，CouchDB还被设计为”shared nothing”<br>集群。集群中的每台机器都是独立的，并从集群中的其它机器同步数据，这就允许单个服务器零时间的宕机。因为重启过程不需要一致性检查和修复，所以即使整个集群崩溃了——例如数据中心电力不足——整个CouchDB分布式系统在重<br>启之后还是可以立刻服务。</p>\n<p>CouchDB 始于一个分布式文档数据库系统的一致性版本机制。CouchDB 不是在同样模型和数据库上组装一些分布式特性，而是从底层开始的工程。CouchDB<br>把文档/视图/安全/同步模型，特定用途的查询语言，高效健壮的磁盘文件布<br>局，以及Erlang平台的并发性和可靠性集中到一个系统当中。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjbnjnr9a0000v4tn50jkmdbo","category_id":"cjbnjnr9o0004v4tntu17ropu","_id":"cjbnjnr9z0009v4tn6nxo05p8"},{"post_id":"cjbnjnr9j0002v4tntu1xapvo","category_id":"cjbnjnr9o0004v4tntu17ropu","_id":"cjbnjnra0000av4tnn7lie9zh"},{"post_id":"cjbnjnr9r0005v4tnbtqmx8xx","category_id":"cjbnjnr9z0008v4tn691dt616","_id":"cjbnjnra0000bv4tnie5drrky"}],"PostTag":[],"Tag":[]}}